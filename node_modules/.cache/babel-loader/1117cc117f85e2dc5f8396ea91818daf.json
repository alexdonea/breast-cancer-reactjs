{"ast":null,"code":"var _jsxFileName = \"/Users/acd/Documents/Projects/breast-cancer-ml/src/App.js\";\nimport React from \"react\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport * as tf from \"@tensorflow/tfjs\";\nimport dataset from \"./Dataset\";\nimport Console from \"./Components/Console\";\nimport Button from \"./Components/Button\";\nimport RadioButton from \"./Components/RadioButton\";\nimport Input from \"./Components/Input\";\nimport Model from \"./Model\";\nimport data from \"./dataset\";\nimport ChartComponent from \"./Components/ChartComponent\";\nimport { Line } from \"react-chartjs-2\";\nimport { fromMemory } from \"@tensorflow/tfjs-core/dist/io/io\";\nconst e = React.createElement;\n\nconst modelStorage = async () => {\n  return await tf.loadLayersModel(\"localstorage://breast-cancer-model\");\n};\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.predictTrainedModel = async () => {\n      const xTest = tf.tensor2d(dataset.xTest, [data.xTest.length, 30]);\n      const yTest = tf.tensor2d(dataset.yTest, [data.yTest.length, 1]);\n      let correct = 0;\n      let wrong = 0;\n      const modelStorage = await tf.loadLayersModel(\"localstorage://breast-cancer-model\");\n      tf.tidy(() => {\n        const output = modelStorage.predict(xTest); // const axis = 1;\n        // const labels = Array.from(yTest.argMax(axis).dataSync());\n        // const predictions = Array.from(output.argMax(axis).dataSync();\n\n        const predictions = output.dataSync();\n        let correct = 0;\n        let wrong = 0; // console.log(predictions);\n\n        predictions.map((value, index) => {\n          const yTestData = yTest.dataSync();\n          console.log(value, yTestData[index]);\n\n          if (yTestData[index] === 1) {\n            const fromTest = value >= 0.5 ? 'Correct' : 'Wrong';\n\n            if (fromTest === 'Correct') {\n              correct++;\n            } else {\n              wrong++;\n            }\n\n            this.addConsoleValue(\"[\".concat(index, \"] = Malignant, Dataset = \").concat(fromTest));\n          } else {\n            const fromTest = value <= 0.5 ? 'Correct' : 'Wrong';\n\n            if (fromTest === 'Correct') {\n              correct++;\n            } else {\n              wrong++;\n            }\n\n            this.addConsoleValue(\"[\".concat(index, \"] = Benign, Dataset = \").concat(fromTest));\n          }\n        });\n        this.addConsoleValue(\"Correct=\".concat(correct, \", Wrong = \").concat(wrong, \" Total=\").concat(correct + wrong)); // console.log('labels',labels,'predictions',predictions);\n      }); // const predictOut = modelStorage.predict(xTest);\n      // const yPred = predictOut.argMax(1);\n      // yPred.print()\n      // const preds = modelStorage.predict(xTest).argMax(-1);\n      // const labels = yTest.argMax(-1);\n      // console.log(preds, labels);\n      // modelStorage.predict(xTest,yTest).print()\n      // yPred.map((predX,index) =>{\n      //   if(predX == 1){\n      //     this.addConsoleValue(`${index} = Maglim`)\n      //   }\n      //   else if (predX === 0){\n      //     this.addConsoleValue(`${index} = Benign`)\n      //   }\n      //   else{\n      //     this.addConsoleValue(`${index} = Erroare`)\n      //   }\n      // })\n      // console.log('modelStorage',modelStorage);\n      // console.log(modelStorage);\n      // const ypred = modelStorage.predict(xTest);\n      //    console.log(ypred);\n      // const testResult = modelStorage.evaluate(xTest, yTest);\n      //     // console.table(testResult);\n      //    let valAcc = 0;\n      //     const testAccPercent = testResult[1].dataSync()[0] * 100;\n      //     const finalValAccPercent = valAcc * 100;\n      //     this.addConsoleValue(\n      //       `Final validation accuracy: ${finalValAccPercent.toFixed(1)}%; ` +\n      //         `Final test accuracy: ${testAccPercent.toFixed(1)}%`\n      // const xData = xTest.dataSync();\n      // const yTrue = yTest.argMax(-1).dataSync();\n      // const predictOut = modelStorage.predict(xTest);\n      // const yPred = predictOut.argMax(1);\n      // console.log(yPred.dataSync());\n      // const dataset = data.dataset;\n      // const yTrain = [];\n      // dataset.map(row => {\n      //   //We do not need ID so we will delete ID from array\n      //   delete row.id;\n      //   //test data using target M=1, B =0;\n      //   yTrain.push([row.diagnosis === \"M\" ? 1 : 0]);\n      //   delete row.diagnosis;\n      //   return row;\n      // });\n      // const xTrain = dataset.map(row => [\n      //       row.radius_mean,\n      //       row.texture_mean,\n      //       row.perimeter_mean,\n      //       row.area_mean,\n      //       row.smoothness_mean,\n      //       row.compactness_mean,\n      //       row.concavity_mean,\n      //       row.concave_points_mean,\n      //       row.symmetry_mean,\n      //       row.fractal_dimension_mean,\n      //       row.radius_se,\n      //       row.texture_se,\n      //       row.perimeter_se,\n      //       row.area_se,\n      //       row.smoothness_se,\n      //       row.compactness_se,\n      //       row.concavity_se,\n      //       row.concave_points_se,\n      //       row.symmetry_se,\n      //       row.fractal_dimension_se,\n      //       row.radius_worst,\n      //       row.texture_worst,\n      //       row.perimeter_worst,\n      //       row.area_worst,\n      //       row.smoothness_worst,\n      //       row.compactness_worst,\n      //       row.concavity_worst,\n      //       row.concave_points_worst,\n      //       row.symmetry_worst,\n      //       row.fractal_dimension_worst ]\n      // );\n      // console.log(xTrain);\n      // const xTensorTrain = tf.tensor2d(xTrain,[xTrain.length,30]);\n      // const yTensorTrain = tf.tensor2d(yTrain,[yTrain.length,1]);\n      // xTensorTrain.print();\n      // yTensorTrain.print();\n      // // console.log(dataset);\n      // console.log(yTensorTrain);\n      //     );\n    };\n\n    this.test = async () => {\n      this.addConsoleValue(\"Training...\"); // const dataset = data.dataset;\n      // const yTrain = [];\n      // dataset.map(row => {\n      //   //We do not need ID so we will delete ID from array\n      //   delete row.id;\n      //   //test data using target M=1, B =0;\n      //   yTrain.push([row.diagnosis === \"M\" ? 1 : 0]);\n      //   delete row.diagnosis;\n      //   return row;\n      // });\n      // const xTrain = dataset.map(row => [\n      //   row.radius_mean,\n      //   row.texture_mean,\n      //   row.perimeter_mean,\n      //   row.area_mean,\n      //   row.smoothness_mean,\n      //   row.compactness_mean,\n      //   row.concavity_mean,\n      //   row.concave_points_mean,\n      //   row.symmetry_mean,\n      //   row.fractal_dimension_mean,\n      //   row.radius_se,\n      //   row.texture_se,\n      //   row.perimeter_se,\n      //   row.area_se,\n      //   row.smoothness_se,\n      //   row.compactness_se,\n      //   row.concavity_se,\n      //   row.concave_points_se,\n      //   row.symmetry_se,\n      //   row.fractal_dimension_se,\n      //   row.radius_worst,\n      //   row.texture_worst,\n      //   row.perimeter_worst,\n      //   row.area_worst,\n      //   row.smoothness_worst,\n      //   row.compactness_worst,\n      //   row.concavity_worst,\n      //   row.concave_points_worst,\n      //   row.symmetry_worst,\n      //   row.fractal_dimension_worst\n      // ]);\n      // console.log(xTrain);\n\n      const xTensorTrain = tf.tensor2d(dataset.xTrain, [dataset.xTrain.length, 30]);\n      const yTensorTrain = tf.tensor2d(dataset.yTrain, [dataset.yTrain.length, 1]); //Create model as sequential\n\n      const model = tf.sequential();\n      const learningRate = this.state.learningRate;\n      const optimizer = tf.train.sgd(learningRate);\n      const inputLayer = tf.layers.dense({\n        units: 16,\n        inputDim: 30,\n        activation: \"relu\"\n      });\n      const hiddenLayer = tf.layers.dense({\n        units: 8,\n        activation: \"relu\"\n      });\n      const hiddenLayer2 = tf.layers.dense({\n        units: 8,\n        activation: \"relu\"\n      });\n      const hiddenLayer3 = tf.layers.dense({\n        units: 8,\n        activation: \"relu\"\n      });\n      const outputLayer = tf.layers.dense({\n        units: 1,\n        activation: \"sigmoid\"\n      });\n      model.add(inputLayer);\n      model.add(hiddenLayer);\n      model.add(hiddenLayer2); // model.add(hiddenLayer3);\n\n      model.add(outputLayer);\n      model.compile({\n        optimizer: \"rmsprop\",\n        //learning rate\n        loss: \"meanSquaredError\",\n        metrics: [\"accuracy\"]\n      });\n      const xTest = tf.tensor2d(data.xTest, [data.xTest.length, 30]);\n      const yTest = tf.tensor2d(data.yTest, [data.yTest.length, 1]);\n      let trainBatchCount = 0;\n      let onIteration = 0;\n      const batchSize = this.state.batchIterations || 0;\n      const trainEpochs = this.state.epochs || 0;\n      const validationSplit = 0.15; //learning rate\n\n      const totalNumBatches = Math.ceil(xTensorTrain.shape[0] * (1 - validationSplit) / batchSize) * trainEpochs;\n      let trainBathcCount = 0;\n      let valAcc;\n      await model.fit(xTensorTrain, yTensorTrain, {\n        batchSize: batchSize,\n        epochs: trainEpochs,\n        // validationData: [xTest, yTest],\n        callbacks: {\n          //   onBatchEnd: async (batch, logs) => {\n          //     this.setState({\n          //       chartData:{\n          //         datasets:[\n          //           { \n          //             label: 'Loss',\n          //     fill: false,\n          //     lineTension: 0.1,\n          //     backgroundColor: \"red\",\n          //     borderColor: \"red\",\n          //     borderCapStyle: 'butt',\n          //     borderDash: [],\n          //     borderDashOffset: 0.0,\n          //     borderJoinStyle: 'miter',\n          //     pointBorderColor: \"red\",\n          //     pointBackgroundColor: '#fff',\n          //     pointBorderWidth: 1,\n          //     pointHoverRadius: 5,\n          //     pointHoverBackgroundColor: \"red\",\n          //     pointHoverBorderColor: \"red\",\n          //     pointHoverBorderWidth: 2,\n          //     pointRadius: 1,\n          //     pointHitRadius: 10,\n          //             data:[...this.state.chartData.datasets[0].data,logs.loss]\n          //           },\n          //           {\n          //              label: 'Accuracy',\n          //     fill: false,\n          //     lineTension: 0.1,\n          //     backgroundColor: 'rgba(75,192,192,0.4)',\n          //     borderColor: 'rgba(75,192,192,1)',\n          //     borderCapStyle: 'butt',\n          //     borderDash: [],\n          //     borderDashOffset: 0.0,\n          //     borderJoinStyle: 'miter',\n          //     pointBorderColor: 'rgba(75,192,192,1)',\n          //     pointBackgroundColor: '#fff',\n          //     pointBorderWidth: 1,\n          //     pointHoverRadius: 5,\n          //     pointHoverBackgroundColor: 'rgba(75,192,192,1)',\n          //     pointHoverBorderColor: 'rgba(220,220,220,1)',\n          //     pointHoverBorderWidth: 2,\n          //     pointRadius: 1,\n          //     pointHitRadius: 10,\n          //             data:[...this.state.chartData.datasets[1].data,logs.acc]\n          //           }\n          //         ]\n          //       }\n          //     })\n          //   },\n          onEpochEnd: async (epoch, logs) => {\n            valAcc = logs.acc; // console.table(logs);\n\n            this.addConsoleValue(\"Epoch =\".concat(epoch, \" Loss=\").concat(logs.loss, \"  Acc=\").concat(logs.acc)); // if (onIteration) {\n            //   // this.addConsoleValue(`On epoch end, ${epoch}, ${logs}`);\n            // }\n          }\n        }\n      }).then(async () => {\n        const testResult = model.evaluate(xTensorTrain, yTensorTrain); // testResult.print();\n        // console.table(testResult);\n\n        const testAccPercent = testResult[0].dataSync()[0] * 100;\n        const finalValAccPercent = valAcc * 100;\n        this.addConsoleValue(\"Final validation accuracy: \".concat(finalValAccPercent.toFixed(1), \"%; \") + \"Final test accuracy: \".concat(testAccPercent.toFixed(1), \"%\")); //  const ypred = model.predict(xTest).print();\n        //  console.log  (ypred)\n        //     tf.tidy(() => {\n        //       const output = model.predict(xTest);\n        //       const axis = 1;\n        // const labels = Array.from(yTest.argMax(axis).dataSync());\n        // const predictions = Array.from(output.argMax(axis).dataSync());\n        //         console.log('labels',labels,'predictions',predictions);\n        //     });   \n        //     await model.save(\"localstorage://breast-cancer-model\");\n        //     console.log(\"cancer saved\");\n        //  const predictions = Array.from(output.argMax(1).dataSync());\n        //  const\n        //  predictions.map((image,index) => {\n        //  });\n        //  console.table(output);\n        //  console.table(predictions);\n        // const xData = xTest.dataSync();\n        // const yTrue = yTest.argMax(-1).dataSync();\n        // const predictOut = model.predict(xTest);\n        // const yPred = predictOut.argMax(1);\n        // yPred.map((predX,index) =>{\n        //   if(predX == 1){\n        //     this.addConsoleValue(`${index} = Maglim`)\n        //   }\n        //   else if (predX === 0){\n        //     this.addConsoleValue(`${index} = Benign`)\n        //   }\n        //   else{\n        //     this.addConsoleValue(`${index} = Erroare`)\n        //   }\n        // })\n        // console.log(xData, yTrue, yPred.dataSync(), predictOut.dataSync());\n      }); // console.log(`Iteration ${i}: ${res.history.loss}`);\n      // }\n\n      console.log(\"finisheeeed,predicting\"); // model.predict(xTest,yTest)\n      // await model.save('downloads://my-model');\n      // const json = fetch('./trained_alex.json');\n      // // const model2 = await tf.loadLayersModel('file:trained_alex.json');\n      // console.log('model2',json);\n    };\n\n    this.clearConsole = this.clearConsole.bind(this);\n    this.addConsoleValue = this.addConsoleValue.bind(this);\n    this.trainingModeAction = this.trainingModeAction.bind(this);\n    this.updateEpochs = this.updateEpochs.bind(this);\n    this.updateLearningRate = this.updateLearningRate.bind(this);\n    this.updatebatchIterations = this.updatebatchIterations.bind(this);\n    this.predictTrainedModel = this.predictTrainedModel.bind(this);\n    this.train = this.train.bind(this);\n    this.state = {\n      console: [],\n      epochs: 100,\n      learningRate: 1.5,\n      batchIterations: 1,\n      mode: \"default\",\n      trainedModel: Model.trainedModelModel,\n      chartData: {\n        datasets: [{\n          label: 'Loss',\n          fill: false,\n          lineTension: 0.1,\n          backgroundColor: \"red\",\n          borderColor: \"red\",\n          borderCapStyle: 'butt',\n          borderDash: [],\n          borderDashOffset: 0.0,\n          borderJoinStyle: 'miter',\n          pointBorderColor: \"red\",\n          pointBackgroundColor: '#fff',\n          pointBorderWidth: 1,\n          pointHoverRadius: 5,\n          pointHoverBackgroundColor: \"red\",\n          pointHoverBorderColor: \"red\",\n          pointHoverBorderWidth: 2,\n          pointRadius: 1,\n          pointHitRadius: 10,\n          data: []\n        }, {\n          label: 'Accuracy',\n          fill: false,\n          lineTension: 0.1,\n          backgroundColor: 'rgba(75,192,192,0.4)',\n          borderColor: 'rgba(75,192,192,1)',\n          borderCapStyle: 'butt',\n          borderDash: [],\n          borderDashOffset: 0.0,\n          borderJoinStyle: 'miter',\n          pointBorderColor: 'rgba(75,192,192,1)',\n          pointBackgroundColor: '#fff',\n          pointBorderWidth: 1,\n          pointHoverRadius: 5,\n          pointHoverBackgroundColor: 'rgba(75,192,192,1)',\n          pointHoverBorderColor: 'rgba(220,220,220,1)',\n          pointHoverBorderWidth: 2,\n          pointRadius: 1,\n          pointHitRadius: 10,\n          data: []\n        }]\n      }\n    };\n  }\n\n  clearConsole() {\n    this.setState({\n      console: []\n    });\n  }\n\n  train() {\n    const date = new Date();\n    this.setState({\n      console: [...this.state.console, \"[\" + date.toLocaleTimeString() + \"]:Epochs \" + this.state.epochs + \"Iter \" + this.state.batchIterations]\n    });\n  }\n\n  updatebatchIterations(iteration) {\n    this.setState({\n      batchIterations: iteration\n    });\n  }\n\n  updateLearningRate(learningRate) {\n    this.setState({\n      learningRate: learningRate\n    });\n  }\n\n  updateEpochs(epoch) {\n    this.setState({\n      epochs: epoch\n    });\n  }\n\n  trainingModeAction(mode) {\n    this.setState({\n      mode: mode\n    });\n  }\n\n  addConsoleValue(value) {\n    const date = new Date();\n    this.setState({\n      console: [...this.state.console, \"[\" + date.toLocaleTimeString() + \"] \" + value]\n    });\n  }\n\n  renderMode(mode) {\n    switch (mode) {\n      default:\n        return e(\"div\", {}, React.createElement(Button, {\n          label: \"Train with default dataset\",\n          onClick: this.test,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 145\n          },\n          __self: this\n        }), React.createElement(Button, {\n          label: \"Predict with test dataset\",\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 146\n          },\n          __self: this\n        }), React.createElement(Button, {\n          label: \"Predict with pre trained model\",\n          onClick: this.predictTrainedModel,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 147\n          },\n          __self: this\n        }), React.createElement(Button, {\n          label: \"Download model\",\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 151\n          },\n          __self: this\n        }));\n\n      case \"custom\":\n        return e(\"p\", {}, \"custom goest here...\");\n    }\n  }\n\n  render() {\n    return e(\"div\", {\n      className: \"container\",\n      style: {\n        position: \"relative\",\n        top: 100\n      }\n    }, e(\"div\", {\n      className: \"row\"\n    }, e(\"div\", {\n      className: \"col-md-6\"\n    }, e(\"p\", null, \"Console\"), React.createElement(Console, {\n      console: this.state.console,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 560\n      },\n      __self: this\n    }), React.createElement(Button, {\n      label: \"Clear\",\n      onClick: this.clearConsole,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 561\n      },\n      __self: this\n    })), e(\"div\", {\n      className: \"col-md-6\"\n    }, e(\"p\", {}, \"Train\"), e(\"p\", null, \"Default Breast Cancer Dataset\"), e(\"div\", {\n      className: \"row\"\n    }, e(\"div\", {\n      className: \"col-md-4\"\n    }, e(\"p\", {}, \"Epochs\"), React.createElement(Input, {\n      placeholder: \"Enter here number of epochs\",\n      value: this.state.epochs,\n      updateValue: this.updateEpochs,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 575\n      },\n      __self: this\n    })), e(\"div\", {\n      className: \"col-md-4\"\n    }, e(\"p\", {}, \"Batch Iterations\"), React.createElement(Input, {\n      placeholder: \"Enter here number of batchIterations\",\n      value: this.state.batchIterations,\n      updateValue: this.updatebatchIterations,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 585\n      },\n      __self: this\n    })), e(\"div\", {\n      className: \"col-md-4\"\n    }, e(\"p\", {}, \"Learning rate\"), React.createElement(Input, {\n      placeholder: \"Learning rate\",\n      value: this.state.learningRate,\n      updateValue: this.updateLearningRate,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 595\n      },\n      __self: this\n    })), e(\"div\", {\n      className: \"col-md-6\"\n    }, React.createElement(RadioButton, {\n      label: \"Default dataset train\",\n      value: \"default\",\n      onModeSelection: this.trainingModeAction,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 604\n      },\n      __self: this\n    })), e(\"div\", {\n      className: \"col-md-6\"\n    }, React.createElement(RadioButton, {\n      label: \"Custom dataset train\",\n      value: \"custom\",\n      onModeSelection: this.trainingModeAction,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 613\n      },\n      __self: this\n    }))), this.renderMode(this.state.mode), // <ChartComponent\n    //   data={this.state.chartData.data}\n    //   title={this.state.chartData.title}\n    // />\n    React.createElement(Line, {\n      data: this.state.chartData // options={chartOptions}\n      ,\n      height: 500,\n      width: 700,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 625\n      },\n      __self: this\n    }))));\n  }\n\n}\n\nexport default App;","map":{"version":3,"sources":["/Users/acd/Documents/Projects/breast-cancer-ml/src/App.js"],"names":["React","tf","dataset","Console","Button","RadioButton","Input","Model","data","ChartComponent","Line","fromMemory","e","createElement","modelStorage","loadLayersModel","App","Component","constructor","props","predictTrainedModel","xTest","tensor2d","length","yTest","correct","wrong","tidy","output","predict","predictions","dataSync","map","value","index","yTestData","console","log","fromTest","addConsoleValue","test","xTensorTrain","xTrain","yTensorTrain","yTrain","model","sequential","learningRate","state","optimizer","train","sgd","inputLayer","layers","dense","units","inputDim","activation","hiddenLayer","hiddenLayer2","hiddenLayer3","outputLayer","add","compile","loss","metrics","trainBatchCount","onIteration","batchSize","batchIterations","trainEpochs","epochs","validationSplit","totalNumBatches","Math","ceil","shape","trainBathcCount","valAcc","fit","callbacks","onEpochEnd","epoch","logs","acc","then","testResult","evaluate","testAccPercent","finalValAccPercent","toFixed","clearConsole","bind","trainingModeAction","updateEpochs","updateLearningRate","updatebatchIterations","mode","trainedModel","trainedModelModel","chartData","datasets","label","fill","lineTension","backgroundColor","borderColor","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","pointBorderColor","pointBackgroundColor","pointBorderWidth","pointHoverRadius","pointHoverBackgroundColor","pointHoverBorderColor","pointHoverBorderWidth","pointRadius","pointHitRadius","setState","date","Date","toLocaleTimeString","iteration","renderMode","render","className","style","position","top"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport * as tf from \"@tensorflow/tfjs\";\nimport dataset from \"./Dataset\";\nimport Console from \"./Components/Console\";\nimport Button from \"./Components/Button\";\nimport RadioButton from \"./Components/RadioButton\";\nimport Input from \"./Components/Input\";\nimport Model from \"./Model\";\nimport data from \"./dataset\";\nimport ChartComponent from \"./Components/ChartComponent\";\nimport {Line} from \"react-chartjs-2\";\nimport { fromMemory } from \"@tensorflow/tfjs-core/dist/io/io\";\n\nconst e = React.createElement;\nconst modelStorage = async () => {\n  return await tf.loadLayersModel(\"localstorage://breast-cancer-model\");\n};\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.clearConsole = this.clearConsole.bind(this);\n    this.addConsoleValue = this.addConsoleValue.bind(this);\n    this.trainingModeAction = this.trainingModeAction.bind(this);\n    this.updateEpochs = this.updateEpochs.bind(this);\n    this.updateLearningRate = this.updateLearningRate.bind(this);\n    this.updatebatchIterations = this.updatebatchIterations.bind(this);\n    this.predictTrainedModel = this.predictTrainedModel.bind(this);\n    this.train = this.train.bind(this);\n    this.state = {\n      console: [],\n      epochs: 100,\n      learningRate: 1.5,\n      batchIterations: 1,\n      mode: \"default\",\n      trainedModel: Model.trainedModelModel,\n      chartData:{\n        datasets: [\n          {\n            label: 'Loss',\n            fill: false,\n            lineTension: 0.1,\n            backgroundColor: \"red\",\n            borderColor: \"red\",\n            borderCapStyle: 'butt',\n            borderDash: [],\n            borderDashOffset: 0.0,\n            borderJoinStyle: 'miter',\n            pointBorderColor: \"red\",\n            pointBackgroundColor: '#fff',\n            pointBorderWidth: 1,\n            pointHoverRadius: 5,\n            pointHoverBackgroundColor: \"red\",\n            pointHoverBorderColor: \"red\",\n            pointHoverBorderWidth: 2,\n            pointRadius: 1,\n            pointHitRadius: 10,\n            data: []\n          },\n          {\n            label: 'Accuracy',\n            fill: false,\n            lineTension: 0.1,\n            backgroundColor: 'rgba(75,192,192,0.4)',\n            borderColor: 'rgba(75,192,192,1)',\n            borderCapStyle: 'butt',\n            borderDash: [],\n            borderDashOffset: 0.0,\n            borderJoinStyle: 'miter',\n            pointBorderColor: 'rgba(75,192,192,1)',\n            pointBackgroundColor: '#fff',\n            pointBorderWidth: 1,\n            pointHoverRadius: 5,\n            pointHoverBackgroundColor: 'rgba(75,192,192,1)',\n            pointHoverBorderColor: 'rgba(220,220,220,1)',\n            pointHoverBorderWidth: 2,\n            pointRadius: 1,\n            pointHitRadius: 10,\n            data: []\n          }\n        ]\n      }\n    };\n  }\n\n  clearConsole() {\n    this.setState({\n      console: []\n    });\n  }\n\n  train() {\n    const date = new Date();\n    this.setState({\n      console: [\n        ...this.state.console,\n        \"[\" +\n          date.toLocaleTimeString() +\n          \"]:Epochs \" +\n          this.state.epochs +\n          \"Iter \" +\n          this.state.batchIterations\n      ]\n    });\n  }\n\n  updatebatchIterations(iteration) {\n    this.setState({\n      batchIterations: iteration\n    });\n  }\n  updateLearningRate(learningRate) {\n    this.setState({\n      learningRate: learningRate\n    });\n  }\n  updateEpochs(epoch) {\n    this.setState({\n      epochs: epoch\n    });\n  }\n\n  trainingModeAction(mode) {\n    this.setState({\n      mode: mode\n    });\n  }\n\n  addConsoleValue(value) {\n    const date = new Date();\n    this.setState({\n      console: [\n        ...this.state.console,\n        \"[\" + date.toLocaleTimeString() + \"] \" + value\n      ]\n    });\n  }\n\n  renderMode(mode) {\n    switch (mode) {\n      default:\n        return e(\n          \"div\",\n          {},\n          <Button label=\"Train with default dataset\" onClick={this.test} />,\n          <Button label=\"Predict with test dataset\" />,\n          <Button\n            label=\"Predict with pre trained model\"\n            onClick={this.predictTrainedModel}\n          />,\n          <Button label=\"Download model\" />\n        );\n      case \"custom\":\n        return e(\"p\", {}, \"custom goest here...\");\n    }\n  }\n  predictTrainedModel = async () => {\n\n    const xTest = tf.tensor2d(dataset.xTest, [data.xTest.length, 30]);\n    const yTest = tf.tensor2d(dataset.yTest, [data.yTest.length, 1]);\n    let correct = 0;\n    let wrong  = 0;\n    const modelStorage = await tf.loadLayersModel(\n      \"localstorage://breast-cancer-model\"\n    );\n\n    tf.tidy(() => {\n      const output = modelStorage.predict(xTest);\n\n      // const axis = 1;\n// const labels = Array.from(yTest.argMax(axis).dataSync());\n// const predictions = Array.from(output.argMax(axis).dataSync();\n      const predictions = output.dataSync();\n      let correct = 0;\n      let wrong = 0;\n      // console.log(predictions);\n      predictions.map((value,index)=>{\n        \n        const yTestData = yTest.dataSync();\n        console.log(value, yTestData[index]);\n        if(yTestData[index] === 1){\n          const fromTest = value >= 0.5 ? 'Correct' : 'Wrong'\n          if(fromTest === 'Correct'){\n            correct++;\n          }\n          else{\n            wrong++;\n          }\n          this.addConsoleValue(`[${index}] = Malignant, Dataset = ${fromTest}`)\n        }\n        else {\n          const fromTest = value <= 0.5 ? 'Correct' : 'Wrong';\n          if(fromTest === 'Correct'){\n            correct++;\n          }\n          else{\n            wrong++;\n          }\n          this.addConsoleValue(`[${index}] = Benign, Dataset = ${fromTest}`)\n        }\n      })\n\n      this.addConsoleValue(`Correct=${correct}, Wrong = ${wrong} Total=${correct+wrong}`)\n        // console.log('labels',labels,'predictions',predictions);\n    \n    }); \n\n\n    // const predictOut = modelStorage.predict(xTest);\n    // const yPred = predictOut.argMax(1);\n    // yPred.print()\n\n    // const preds = modelStorage.predict(xTest).argMax(-1);\n    // const labels = yTest.argMax(-1);\n\n    // console.log(preds, labels);\n    // modelStorage.predict(xTest,yTest).print()\n    // yPred.map((predX,index) =>{\n    //   if(predX == 1){\n    //     this.addConsoleValue(`${index} = Maglim`)\n    //   }\n    //   else if (predX === 0){\n    //     this.addConsoleValue(`${index} = Benign`)\n    //   }\n    //   else{\n    //     this.addConsoleValue(`${index} = Erroare`)\n    //   }\n    // })\n    // console.log('modelStorage',modelStorage);\n    // console.log(modelStorage);\n    // const ypred = modelStorage.predict(xTest);\n    //    console.log(ypred);\n\n    // const testResult = modelStorage.evaluate(xTest, yTest);\n    //     // console.table(testResult);\n    //    let valAcc = 0;\n    //     const testAccPercent = testResult[1].dataSync()[0] * 100;\n    //     const finalValAccPercent = valAcc * 100;\n    //     this.addConsoleValue(\n    //       `Final validation accuracy: ${finalValAccPercent.toFixed(1)}%; ` +\n    //         `Final test accuracy: ${testAccPercent.toFixed(1)}%`\n\n    // const xData = xTest.dataSync();\n    // const yTrue = yTest.argMax(-1).dataSync();\n    // const predictOut = modelStorage.predict(xTest);\n    // const yPred = predictOut.argMax(1);\n\n    // console.log(yPred.dataSync());\n\n    // const dataset = data.dataset;\n    // const yTrain = [];\n    // dataset.map(row => {\n    //   //We do not need ID so we will delete ID from array\n    //   delete row.id;\n    //   //test data using target M=1, B =0;\n    //   yTrain.push([row.diagnosis === \"M\" ? 1 : 0]);\n    //   delete row.diagnosis;\n    //   return row;\n    // });\n    // const xTrain = dataset.map(row => [\n    //       row.radius_mean,\n    //       row.texture_mean,\n    //       row.perimeter_mean,\n    //       row.area_mean,\n    //       row.smoothness_mean,\n    //       row.compactness_mean,\n    //       row.concavity_mean,\n    //       row.concave_points_mean,\n    //       row.symmetry_mean,\n    //       row.fractal_dimension_mean,\n    //       row.radius_se,\n    //       row.texture_se,\n    //       row.perimeter_se,\n    //       row.area_se,\n    //       row.smoothness_se,\n    //       row.compactness_se,\n    //       row.concavity_se,\n    //       row.concave_points_se,\n    //       row.symmetry_se,\n    //       row.fractal_dimension_se,\n    //       row.radius_worst,\n    //       row.texture_worst,\n    //       row.perimeter_worst,\n    //       row.area_worst,\n    //       row.smoothness_worst,\n    //       row.compactness_worst,\n    //       row.concavity_worst,\n    //       row.concave_points_worst,\n    //       row.symmetry_worst,\n    //       row.fractal_dimension_worst ]\n\n    // );\n\n    // console.log(xTrain);\n    // const xTensorTrain = tf.tensor2d(xTrain,[xTrain.length,30]);\n    // const yTensorTrain = tf.tensor2d(yTrain,[yTrain.length,1]);\n\n    // xTensorTrain.print();\n    // yTensorTrain.print();\n    // // console.log(dataset);\n    // console.log(yTensorTrain);\n\n    //     );\n  };\n  test = async () => {\n    this.addConsoleValue(\"Training...\");\n\n    // const dataset = data.dataset;\n    // const yTrain = [];\n    // dataset.map(row => {\n    //   //We do not need ID so we will delete ID from array\n    //   delete row.id;\n    //   //test data using target M=1, B =0;\n    //   yTrain.push([row.diagnosis === \"M\" ? 1 : 0]);\n    //   delete row.diagnosis;\n    //   return row;\n    // });\n    // const xTrain = dataset.map(row => [\n    //   row.radius_mean,\n    //   row.texture_mean,\n    //   row.perimeter_mean,\n    //   row.area_mean,\n    //   row.smoothness_mean,\n    //   row.compactness_mean,\n    //   row.concavity_mean,\n    //   row.concave_points_mean,\n    //   row.symmetry_mean,\n    //   row.fractal_dimension_mean,\n    //   row.radius_se,\n    //   row.texture_se,\n    //   row.perimeter_se,\n    //   row.area_se,\n    //   row.smoothness_se,\n    //   row.compactness_se,\n    //   row.concavity_se,\n    //   row.concave_points_se,\n    //   row.symmetry_se,\n    //   row.fractal_dimension_se,\n    //   row.radius_worst,\n    //   row.texture_worst,\n    //   row.perimeter_worst,\n    //   row.area_worst,\n    //   row.smoothness_worst,\n    //   row.compactness_worst,\n    //   row.concavity_worst,\n    //   row.concave_points_worst,\n    //   row.symmetry_worst,\n    //   row.fractal_dimension_worst\n    // ]);\n\n    // console.log(xTrain);\n    const xTensorTrain = tf.tensor2d(dataset.xTrain, [dataset.xTrain.length, 30]);\n    const yTensorTrain = tf.tensor2d(dataset.yTrain, [dataset.yTrain.length, 1]);\n\n    //Create model as sequential\n\n    const model = tf.sequential();\n    const learningRate = this.state.learningRate;\n    const optimizer = tf.train.sgd(learningRate);\n    const inputLayer = tf.layers.dense({\n      units: 16,\n      inputDim: 30,\n      activation: \"relu\"\n    });\n\n    const hiddenLayer = tf.layers.dense({\n      units: 8,\n      activation: \"relu\"\n    });\n\n    const hiddenLayer2 = tf.layers.dense({\n      units: 8,\n      activation: \"relu\"\n    });\n    const hiddenLayer3 = tf.layers.dense({\n      units: 8,\n      activation: \"relu\"\n    });\n\n    const outputLayer = tf.layers.dense({\n      units: 1,\n      activation: \"sigmoid\"\n    });\n\n    model.add(inputLayer);\n    model.add(hiddenLayer);\n    model.add(hiddenLayer2);\n    // model.add(hiddenLayer3);\n    model.add(outputLayer);\n\n    model.compile({\n      optimizer: \"rmsprop\", //learning rate\n      loss: \"meanSquaredError\",\n      metrics: [\"accuracy\"]\n    });\n\n    const xTest = tf.tensor2d(data.xTest, [data.xTest.length, 30]);\n    const yTest = tf.tensor2d(data.yTest, [data.yTest.length, 1]);\n    let trainBatchCount = 0;\n    let onIteration = 0;\n    const batchSize = this.state.batchIterations || 0;\n    const trainEpochs = this.state.epochs || 0;\n    const validationSplit = 0.15; //learning rate\n    const totalNumBatches = Math.ceil(xTensorTrain.shape[0] * (1 - validationSplit) / batchSize) *trainEpochs;\n    let trainBathcCount = 0;\n    let valAcc;\n    await model\n      .fit(xTensorTrain, yTensorTrain, {\n        batchSize: batchSize,\n        epochs: trainEpochs,\n        // validationData: [xTest, yTest],\n        callbacks: {\n        //   onBatchEnd: async (batch, logs) => {\n        //     this.setState({\n        //       chartData:{\n        //         datasets:[\n        //           { \n        //             label: 'Loss',\n        //     fill: false,\n        //     lineTension: 0.1,\n        //     backgroundColor: \"red\",\n        //     borderColor: \"red\",\n        //     borderCapStyle: 'butt',\n        //     borderDash: [],\n        //     borderDashOffset: 0.0,\n        //     borderJoinStyle: 'miter',\n        //     pointBorderColor: \"red\",\n        //     pointBackgroundColor: '#fff',\n        //     pointBorderWidth: 1,\n        //     pointHoverRadius: 5,\n        //     pointHoverBackgroundColor: \"red\",\n        //     pointHoverBorderColor: \"red\",\n        //     pointHoverBorderWidth: 2,\n        //     pointRadius: 1,\n        //     pointHitRadius: 10,\n        //             data:[...this.state.chartData.datasets[0].data,logs.loss]\n        //           },\n        //           {\n        //              label: 'Accuracy',\n        //     fill: false,\n        //     lineTension: 0.1,\n        //     backgroundColor: 'rgba(75,192,192,0.4)',\n        //     borderColor: 'rgba(75,192,192,1)',\n        //     borderCapStyle: 'butt',\n        //     borderDash: [],\n        //     borderDashOffset: 0.0,\n        //     borderJoinStyle: 'miter',\n        //     pointBorderColor: 'rgba(75,192,192,1)',\n        //     pointBackgroundColor: '#fff',\n        //     pointBorderWidth: 1,\n        //     pointHoverRadius: 5,\n        //     pointHoverBackgroundColor: 'rgba(75,192,192,1)',\n        //     pointHoverBorderColor: 'rgba(220,220,220,1)',\n        //     pointHoverBorderWidth: 2,\n        //     pointRadius: 1,\n        //     pointHitRadius: 10,\n        //             data:[...this.state.chartData.datasets[1].data,logs.acc]\n        //           }\n        //         ]\n        //       }\n        //     })\n        //   },\n          onEpochEnd: async (epoch, logs) => {\n            valAcc = logs.acc;\n            // console.table(logs);\n            this.addConsoleValue(\n              `Epoch =${epoch} Loss=${logs.loss}  Acc=${logs.acc}`\n            );\n            // if (onIteration) {\n            //   // this.addConsoleValue(`On epoch end, ${epoch}, ${logs}`);\n            // }\n          }\n        }\n      })\n      .then(async () => {\n        const testResult = model.evaluate(xTensorTrain, yTensorTrain);\n        // testResult.print();\n        // console.table(testResult);\n\n        const testAccPercent = testResult[0].dataSync()[0] * 100;\n        const finalValAccPercent = valAcc * 100;\n        this.addConsoleValue(\n          `Final validation accuracy: ${finalValAccPercent.toFixed(1)}%; ` +\n            `Final test accuracy: ${testAccPercent.toFixed(1)}%`\n        );\n\n        //  const ypred = model.predict(xTest).print();\n        //  console.log  (ypred)\n\n    //     tf.tidy(() => {\n    //       const output = model.predict(xTest);\n\n    //       const axis = 1;\n    // const labels = Array.from(yTest.argMax(axis).dataSync());\n    // const predictions = Array.from(output.argMax(axis).dataSync());\n    //         console.log('labels',labels,'predictions',predictions);\n        \n    //     });   \n\n    //     await model.save(\"localstorage://breast-cancer-model\");\n\n    //     console.log(\"cancer saved\");\n\n        //  const predictions = Array.from(output.argMax(1).dataSync());\n        //  const\n        //  predictions.map((image,index) => {\n\n        //  });\n\n        //  console.table(output);\n        //  console.table(predictions);\n        // const xData = xTest.dataSync();\n        // const yTrue = yTest.argMax(-1).dataSync();\n        // const predictOut = model.predict(xTest);\n        // const yPred = predictOut.argMax(1);\n\n        // yPred.map((predX,index) =>{\n        //   if(predX == 1){\n        //     this.addConsoleValue(`${index} = Maglim`)\n        //   }\n        //   else if (predX === 0){\n        //     this.addConsoleValue(`${index} = Benign`)\n        //   }\n        //   else{\n        //     this.addConsoleValue(`${index} = Erroare`)\n        //   }\n        // })\n\n        // console.log(xData, yTrue, yPred.dataSync(), predictOut.dataSync());\n      });\n    // console.log(`Iteration ${i}: ${res.history.loss}`);\n    // }\n\n    console.log(\"finisheeeed,predicting\");\n    // model.predict(xTest,yTest)\n    // await model.save('downloads://my-model');\n\n    // const json = fetch('./trained_alex.json');\n    // // const model2 = await tf.loadLayersModel('file:trained_alex.json');\n    // console.log('model2',json);\n  };\n\n  render() {\n    return e(\n      \"div\",\n      {\n        className: \"container\",\n        style: {\n          position: \"relative\",\n          top: 100\n        }\n      },\n      e(\n        \"div\",\n        { className: \"row\" },\n        e(\n          \"div\",\n          { className: \"col-md-6\" },\n          e(\"p\", null, \"Console\"),\n          <Console console={this.state.console} />,\n          <Button label=\"Clear\" onClick={this.clearConsole} />\n        ),\n        e(\n          \"div\",\n          { className: \"col-md-6\" },\n          e(\"p\", {}, \"Train\"),\n          e(\"p\", null, \"Default Breast Cancer Dataset\"),\n          e(\n            \"div\",\n            { className: \"row\" },\n            e(\n              \"div\",\n              { className: \"col-md-4\" },\n              e(\"p\", {}, \"Epochs\"),\n              <Input\n                placeholder=\"Enter here number of epochs\"\n                value={this.state.epochs}\n                updateValue={this.updateEpochs}\n              />\n            ),\n            e(\n              \"div\",\n              { className: \"col-md-4\" },\n              e(\"p\", {}, \"Batch Iterations\"),\n              <Input\n                placeholder=\"Enter here number of batchIterations\"\n                value={this.state.batchIterations}\n                updateValue={this.updatebatchIterations}\n              />\n            ),\n            e(\n              \"div\",\n              { className: \"col-md-4\" },\n              e(\"p\", {}, \"Learning rate\"),\n              <Input\n                placeholder=\"Learning rate\"\n                value={this.state.learningRate}\n                updateValue={this.updateLearningRate}\n              />\n            ),\n            e(\n              \"div\",\n              { className: \"col-md-6\" },\n              <RadioButton\n                label=\"Default dataset train\"\n                value=\"default\"\n                onModeSelection={this.trainingModeAction}\n              />\n            ),\n            e(\n              \"div\",\n              { className: \"col-md-6\" },\n              <RadioButton\n                label=\"Custom dataset train\"\n                value=\"custom\"\n                onModeSelection={this.trainingModeAction}\n              />\n            )\n          ),\n          this.renderMode(this.state.mode),\n          // <ChartComponent\n          //   data={this.state.chartData.data}\n          //   title={this.state.chartData.title}\n          // />\n          < Line\n          data={this.state.chartData}\n          // options={chartOptions}\n          height={500}\n          width={700}\n          />\n        )\n      )\n    );\n  }\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}