{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar engine_1 = require(\"../engine\");\n\nvar environment_1 = require(\"../environment\");\n\nvar tensor_util_env_1 = require(\"../tensor_util_env\");\n\nvar util_1 = require(\"../util\");\n\nvar complex_ops_1 = require(\"./complex_ops\");\n\nvar operation_1 = require(\"./operation\");\n/**\n * Creates a `tf.Tensor` with the provided values, shape and dtype.\n *\n * ```js\n * // Pass an array of values to create a vector.\n * tf.tensor([1, 2, 3, 4]).print();\n * ```\n *\n * ```js\n * // Pass a nested array of values to make a matrix or a higher\n * // dimensional tensor.\n * tf.tensor([[1, 2], [3, 4]]).print();\n * ```\n *\n * ```js\n * // Pass a flat array and specify a shape yourself.\n * tf.tensor([1, 2, 3, 4], [2, 2]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`. If the values are strings,\n *     they will be encoded as utf-8 and kept as `Uint8Array[]`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction tensor(values, shape, dtype) {\n  var inferredShape = tensor_util_env_1.inferShape(values, dtype);\n  return makeTensor(values, shape, inferredShape, dtype);\n}\n\nexports.tensor = tensor;\n/** This is shared code across all tensor creation methods. */\n\nfunction makeTensor(values, shape, inferredShape, dtype) {\n  if (dtype == null) {\n    dtype = util_1.inferDtype(values);\n  }\n\n  if (dtype === 'complex64') {\n    throw new Error(\"Cannot construct a complex64 tensor directly. \" + \"Please use tf.complex(real, imag).\");\n  }\n\n  if (!util_1.isTypedArray(values) && !Array.isArray(values) && typeof values !== 'number' && typeof values !== 'boolean' && typeof values !== 'string') {\n    throw new Error('values passed to tensor(values) must be a number/boolean/string or ' + 'an array of numbers/booleans/strings, or a TypedArray');\n  }\n\n  if (shape != null) {\n    util_1.assertNonNegativeIntegerDimensions(shape);\n    var providedSize_1 = util_1.sizeFromShape(shape);\n    var inferredSize_1 = util_1.sizeFromShape(inferredShape);\n    util_1.assert(providedSize_1 === inferredSize_1, function () {\n      return \"Based on the provided shape, [\" + shape + \"], the tensor should have \" + (providedSize_1 + \" values but has \" + inferredSize_1);\n    });\n\n    for (var i = 0; i < inferredShape.length; ++i) {\n      var inferred = inferredShape[i];\n      var flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== util_1.sizeFromShape(shape.slice(i)) : true;\n      util_1.assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, function () {\n        return \"Error creating a new Tensor. Inferred shape \" + (\"(\" + inferredShape + \") does not match the provided \") + (\"shape (\" + shape + \"). \");\n      });\n    }\n  }\n\n  if (!util_1.isTypedArray(values) && !Array.isArray(values)) {\n    values = [values];\n  }\n\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ? util_1.toTypedArray(values, dtype, environment_1.env().getBool('DEBUG')) : util_1.flatten(values, [], true);\n  return engine_1.ENGINE.makeTensor(values, shape, dtype);\n}\n/**\n * Creates rank-0 `tf.Tensor` (scalar) with the provided value and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.scalar` as it makes the code more readable.\n *\n * ```js\n * tf.scalar(3.14).print();\n * ```\n *\n * @param value The value of the scalar.\n * @param dtype The data type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction scalar(value, dtype) {\n  if ((util_1.isTypedArray(value) && dtype !== 'string' || Array.isArray(value)) && dtype !== 'complex64') {\n    throw new Error('Error creating a new Scalar: value must be a primitive ' + '(number|boolean|string)');\n  }\n\n  if (dtype === 'string' && util_1.isTypedArray(value) && !(value instanceof Uint8Array)) {\n    throw new Error('When making a scalar from encoded string, ' + 'the value must be `Uint8Array`.');\n  }\n\n  var shape = [];\n  var inferredShape = [];\n  return makeTensor(value, shape, inferredShape, dtype);\n}\n\nexports.scalar = scalar;\n/**\n * Creates rank-1 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor1d` as it makes the code more readable.\n *\n * ```js\n * tf.tensor1d([1, 2, 3]).print();\n * ```\n *\n * @param values The values of the tensor. Can be array of numbers,\n *     or a `TypedArray`.\n * @param dtype The data type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\nfunction tensor1d(values, dtype) {\n  util_1.assertNonNull(values);\n  var inferredShape = tensor_util_env_1.inferShape(values, dtype);\n\n  if (inferredShape.length !== 1) {\n    throw new Error('tensor1d() requires values to be a flat/TypedArray');\n  }\n\n  var shape = null;\n  return makeTensor(values, shape, inferredShape, dtype);\n}\n\nexports.tensor1d = tensor1d;\n/**\n * Creates rank-2 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor2d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor2d([[1, 2], [3, 4]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor2d([1, 2, 3, 4], [2, 2]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. If not provided, it is inferred from\n *     `values`.\n * @param dtype The data type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\nfunction tensor2d(values, shape, dtype) {\n  util_1.assertNonNull(values);\n\n  if (shape != null && shape.length !== 2) {\n    throw new Error('tensor2d() requires shape to have two numbers');\n  }\n\n  var inferredShape = tensor_util_env_1.inferShape(values, dtype);\n\n  if (inferredShape.length !== 2 && inferredShape.length !== 1) {\n    throw new Error('tensor2d() requires values to be number[][] or flat/TypedArray');\n  }\n\n  if (inferredShape.length === 1 && shape == null) {\n    throw new Error('tensor2d() requires shape to be provided when `values` ' + 'are a flat/TypedArray');\n  }\n\n  return makeTensor(values, shape, inferredShape, dtype);\n}\n\nexports.tensor2d = tensor2d;\n/**\n * Creates rank-3 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor3d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor3d([[[1], [2]], [[3], [4]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor3d([1, 2, 3, 4], [2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. If not provided,  it is inferred from\n *     `values`.\n * @param dtype The data type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\nfunction tensor3d(values, shape, dtype) {\n  util_1.assertNonNull(values);\n\n  if (shape != null && shape.length !== 3) {\n    throw new Error('tensor3d() requires shape to have three numbers');\n  }\n\n  var inferredShape = tensor_util_env_1.inferShape(values, dtype);\n\n  if (inferredShape.length !== 3 && inferredShape.length !== 1) {\n    throw new Error('tensor3d() requires values to be number[][][] or flat/TypedArray');\n  }\n\n  if (inferredShape.length === 1 && shape == null) {\n    throw new Error('tensor3d() requires shape to be provided when `values` ' + 'are a flat array');\n  }\n\n  return makeTensor(values, shape, inferredShape, dtype);\n}\n\nexports.tensor3d = tensor3d;\n/**\n * Creates rank-4 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor4d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor4d([[[[1], [2]], [[3], [4]]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor4d([1, 2, 3, 4], [1, 2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\nfunction tensor4d(values, shape, dtype) {\n  util_1.assertNonNull(values);\n\n  if (shape != null && shape.length !== 4) {\n    throw new Error('tensor4d() requires shape to have four numbers');\n  }\n\n  var inferredShape = tensor_util_env_1.inferShape(values, dtype);\n\n  if (inferredShape.length !== 4 && inferredShape.length !== 1) {\n    throw new Error('tensor4d() requires values to be number[][][][] or flat/TypedArray');\n  }\n\n  if (inferredShape.length === 1 && shape == null) {\n    throw new Error('tensor4d() requires shape to be provided when `values` ' + 'are a flat array');\n  }\n\n  return makeTensor(values, shape, inferredShape, dtype);\n}\n\nexports.tensor4d = tensor4d;\n/**\n * Creates rank-5 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor5d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor5d([[[[[1], [2]], [[3], [4]]]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\nfunction tensor5d(values, shape, dtype) {\n  util_1.assertNonNull(values);\n\n  if (shape != null && shape.length !== 5) {\n    throw new Error('tensor5d() requires shape to have five numbers');\n  }\n\n  var inferredShape = tensor_util_env_1.inferShape(values, dtype);\n\n  if (inferredShape.length !== 5 && inferredShape.length !== 1) {\n    throw new Error('tensor5d() requires values to be ' + 'number[][][][][] or flat/TypedArray');\n  }\n\n  if (inferredShape.length === 1 && shape == null) {\n    throw new Error('tensor5d() requires shape to be provided when `values` ' + 'are a flat array');\n  }\n\n  return makeTensor(values, shape, inferredShape, dtype);\n}\n\nexports.tensor5d = tensor5d;\n/**\n * Creates rank-6 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor6d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor6d([[[[[[1],[2]],[[3],[4]]],[[[5],[6]],[[7],[8]]]]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor6d([1, 2, 3, 4, 5, 6, 7, 8], [1, 1, 2, 2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\nfunction tensor6d(values, shape, dtype) {\n  util_1.assertNonNull(values);\n\n  if (shape != null && shape.length !== 6) {\n    throw new Error('tensor6d() requires shape to have six numbers');\n  }\n\n  var inferredShape = tensor_util_env_1.inferShape(values, dtype);\n\n  if (inferredShape.length !== 6 && inferredShape.length !== 1) {\n    throw new Error('tensor6d() requires values to be number[][][][][][] or ' + 'flat/TypedArray');\n  }\n\n  if (inferredShape.length === 1 && shape == null) {\n    throw new Error('tensor6d() requires shape to be provided when `values` ' + 'are a flat array');\n  }\n\n  shape = shape || inferredShape;\n  return makeTensor(values, shape, inferredShape, dtype);\n}\n\nexports.tensor6d = tensor6d;\n/**\n * Creates a new variable with the provided initial value.\n * ```js\n * const x = tf.variable(tf.tensor([1, 2, 3]));\n * x.assign(tf.tensor([4, 5, 6]));\n *\n * x.print();\n * ```\n *\n * @param initialValue Initial value for the tensor.\n * @param trainable If true, optimizers are allowed to update it.\n * @param name Name of the variable. Defaults to a unique id.\n * @param dtype If set, initialValue will be converted to the given type.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\nfunction variable(initialValue, trainable, name, dtype) {\n  if (trainable === void 0) {\n    trainable = true;\n  }\n\n  return engine_1.ENGINE.makeVariable(initialValue, trainable, name, dtype);\n}\n\nexports.variable = variable;\n/**\n * Creates a `tf.Tensor` with all elements set to 1.\n *\n * ```js\n * tf.ones([2, 2]).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param dtype The type of an element in the resulting tensor. Defaults to\n *     'float'.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\nfunction ones(shape, dtype) {\n  if (dtype === void 0) {\n    dtype = 'float32';\n  }\n\n  if (dtype === 'complex64') {\n    var real_1 = ones(shape, 'float32');\n    var imag_1 = zeros(shape, 'float32');\n    return complex_ops_1.complex(real_1, imag_1);\n  }\n\n  var values = util_1.makeOnesTypedArray(util_1.sizeFromShape(shape), dtype);\n  return engine_1.ENGINE.makeTensor(values, shape, dtype);\n}\n\nexports.ones = ones;\n/**\n * Creates a `tf.Tensor` with all elements set to 0.\n *\n * ```js\n * tf.zeros([2, 2]).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param dtype The type of an element in the resulting tensor. Can\n *     be 'float32', 'int32' or 'bool'. Defaults to 'float'.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\nfunction zeros(shape, dtype) {\n  if (dtype === void 0) {\n    dtype = 'float32';\n  }\n\n  if (dtype === 'complex64') {\n    var real_2 = zeros(shape, 'float32');\n    var imag_2 = zeros(shape, 'float32');\n    return complex_ops_1.complex(real_2, imag_2);\n  }\n\n  var values = util_1.makeZerosTypedArray(util_1.sizeFromShape(shape), dtype);\n  return engine_1.ENGINE.makeTensor(values, shape, dtype);\n}\n\nexports.zeros = zeros;\n/**\n * Creates a `tf.Tensor` filled with a scalar value.\n *\n * ```js\n * tf.fill([2, 2], 4).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param value The scalar value to fill the tensor with.\n * @param dtype The type of an element in the resulting tensor. Defaults to\n * 'float'.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\nfunction fill(shape, value, dtype) {\n  return engine_1.ENGINE.runKernelFunc(function (backend) {\n    return backend.fill(shape, value, dtype);\n  }, {});\n}\n\nexports.fill = fill;\n/**\n * Creates a `tf.Tensor` with all elements set to 1 with the same shape as the\n * given tensor.\n *\n * ```js\n * const x = tf.tensor([1, 2]);\n * tf.onesLike(x).print();\n * ```\n * @param x A tensor.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\nfunction onesLike_(x) {\n  var $x = tensor_util_env_1.convertToTensor(x, 'x', 'onesLike');\n\n  if ($x.dtype === 'complex64') {\n    var r = exports.onesLike(complex_ops_1.real($x));\n    var i = exports.zerosLike(complex_ops_1.imag($x));\n    return complex_ops_1.complex(r, i);\n  }\n\n  var der = function (dy, saved) {\n    return {\n      $x: function () {\n        return exports.zerosLike(dy);\n      }\n    };\n  };\n\n  return engine_1.ENGINE.runKernelFunc(function (backend) {\n    return backend.onesLike($x);\n  }, {\n    $x: $x\n  }, der);\n}\n/**\n * Creates a `tf.Tensor` with all elements set to 0 with the same shape as the\n * given tensor.\n *\n * ```js\n * const x = tf.tensor([1, 2]);\n * tf.zerosLike(x).print();\n * ```\n *\n * @param x The tensor of required shape.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction zerosLike_(x) {\n  var $x = tensor_util_env_1.convertToTensor(x, 'x', 'zerosLike');\n\n  var der = function (dy, saved) {\n    return {\n      $x: function () {\n        return exports.zerosLike(dy);\n      }\n    };\n  };\n\n  return engine_1.ENGINE.runKernelFunc(function (backend) {\n    return backend.zerosLike($x);\n  }, {\n    $x: $x\n  }, der);\n}\n/**\n * Return an evenly spaced sequence of numbers over the given interval.\n *\n * ```js\n * tf.linspace(0, 9, 10).print();\n * ```\n * @param start The start value of the sequence.\n * @param stop The end value of the sequence.\n * @param num The number of values to generate.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\n\nfunction linspace(start, stop, num) {\n  if (num <= 0) {\n    throw new Error('The number of values should be positive.');\n  }\n\n  return engine_1.ENGINE.runKernelFunc(function (backend) {\n    return backend.linspace(start, stop, num);\n  }, {});\n}\n\nexports.linspace = linspace;\n/**\n * Creates a new `tf.Tensor1D` filled with the numbers in the range provided.\n *\n * The tensor is a is half-open interval meaning it includes start, but\n * excludes stop. Decrementing ranges and negative step values are also\n * supported.\n *\n * ```js\n * tf.range(0, 9, 2).print();\n * ```\n *\n * @param start An integer start value\n * @param stop An integer stop value\n * @param step An integer increment (will default to 1 or -1)\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\n */\n\n/** @doc {heading: 'Tensors', subheading: 'Creation'} */\n\nfunction range(start, stop, step, dtype) {\n  if (step === void 0) {\n    step = 1;\n  }\n\n  if (dtype === void 0) {\n    dtype = 'float32';\n  }\n\n  if (step === 0) {\n    throw new Error('Cannot have a step of zero');\n  }\n\n  var sameStartStop = start === stop;\n  var increasingRangeNegativeStep = start < stop && step < 0;\n  var decreasingRangePositiveStep = stop < start && step > 1;\n\n  if (sameStartStop || increasingRangeNegativeStep || decreasingRangePositiveStep) {\n    return zeros([0], dtype);\n  }\n\n  var numElements = Math.abs(Math.ceil((stop - start) / step));\n  var values = util_1.makeZerosTypedArray(numElements, dtype);\n\n  if (stop < start && step === 1) {\n    // Auto adjust the step's sign if it hasn't been set\n    // (or was set to 1)\n    step = -1;\n  }\n\n  values[0] = start;\n\n  for (var i = 1; i < values.length; i++) {\n    values[i] = values[i - 1] + step;\n  }\n\n  return tensor1d(values, dtype);\n}\n\nexports.range = range;\nexports.onesLike = operation_1.op({\n  onesLike_: onesLike_\n});\nexports.zerosLike = operation_1.op({\n  zerosLike_: zerosLike_\n});","map":null,"metadata":{},"sourceType":"script"}