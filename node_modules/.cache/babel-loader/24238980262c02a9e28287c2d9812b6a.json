{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util = require(\"./util\");\n\nvar Profiler =\n/** @class */\nfunction () {\n  function Profiler(backendTimer, logger) {\n    this.backendTimer = backendTimer;\n    this.logger = logger;\n\n    if (logger == null) {\n      this.logger = new Logger();\n    }\n  }\n\n  Profiler.prototype.profileKernel = function (kernelName, inputs, f) {\n    var _this = this;\n\n    var outputs;\n\n    var holdResultWrapperFn = function () {\n      outputs = f();\n    };\n\n    var timer = this.backendTimer.time(holdResultWrapperFn);\n    outputs.forEach(function (r) {\n      // Dangling promise here because we don't want to propagate up\n      // asynchronicity.\n      r.data().then(function (vals) {\n        checkComputationForErrors(vals, r.dtype, kernelName);\n        timer.then(function (timing) {\n          var extraInfo = '';\n\n          if (timing.getExtraProfileInfo != null) {\n            extraInfo = timing.getExtraProfileInfo();\n          }\n\n          _this.logger.logKernelProfile(kernelName, r, vals, timing.kernelMs, inputs, extraInfo);\n        });\n      });\n    });\n    return outputs;\n  };\n\n  return Profiler;\n}();\n\nexports.Profiler = Profiler;\n\nfunction checkComputationForErrors(vals, dtype, kernelName) {\n  if (dtype !== 'float32') {\n    // Only floating point computations will generate NaN values\n    return false;\n  }\n\n  for (var i = 0; i < vals.length; i++) {\n    var num = vals[i];\n\n    if (isNaN(num) || !isFinite(num)) {\n      // Throwing custom exception so behavior is testable.\n      console.warn(\"Found \" + num + \" in the result of '\" + kernelName + \"'\");\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.checkComputationForErrors = checkComputationForErrors;\n\nvar Logger =\n/** @class */\nfunction () {\n  function Logger() {}\n\n  Logger.prototype.logKernelProfile = function (name, result, vals, timeMs, inputs, extraInfo) {\n    var time = util.rightPad(timeMs + \"ms\", 9);\n    var paddedName = util.rightPad(name, 25);\n    var rank = result.rank;\n    var size = result.size;\n    var shape = util.rightPad(result.shape.toString(), 14);\n    var inputShapesDescription = '';\n\n    for (var name_1 in inputs) {\n      var inputShape = inputs[name_1].shape;\n      var inputRank = inputShape.length;\n      inputShapesDescription += name_1 + \": \" + inputRank + \"D \" + (inputRank > 0 ? inputShape : '') + \" \";\n    }\n\n    console.log(\"%c\" + paddedName + \"\\t%c\" + time + \"\\t%c\" + rank + \"D \" + shape + \"\\t%c\" + size + \"\\t%c\" + inputShapesDescription + \"\\t%c\" + extraInfo, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange', 'color: green', 'color: steelblue');\n  };\n\n  return Logger;\n}();\n\nexports.Logger = Logger;","map":null,"metadata":{},"sourceType":"script"}