{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar environment_1 = require(\"../environment\");\n\nvar util = require(\"../util\");\n\nvar io_utils_1 = require(\"./io_utils\");\n\nvar progress_1 = require(\"./progress\");\n\nvar types_1 = require(\"./types\");\n/**\n * Reads binary weights data from a number of URLs.\n *\n * @param fetchURLs URLs to send the HTTP requests at, using `fetch` calls.\n * @param requestOptions RequestInit (options) for the HTTP requests.\n * @param fetchFunc Optional overriding value for the `window.fetch` function.\n * @param onProgress Optional, progress callback function, fired periodically\n *   before the load is completed.\n * @returns A `Promise` of an Array of `ArrayBuffer`. The Array has the same\n *   length as `fetchURLs`.\n */\n\n\nfunction loadWeightsAsArrayBuffer(fetchURLs, loadOptions) {\n  return __awaiter(this, void 0, void 0, function () {\n    var fetchFunc, requests, fetchStartFraction, fetchEndFraction, responses, _a, bufferPromises, bufferStartFraction, bufferEndFraction, buffers, _b;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          if (loadOptions == null) {\n            loadOptions = {};\n          }\n\n          fetchFunc = loadOptions.fetchFunc == null ? environment_1.env().platform.fetch : loadOptions.fetchFunc;\n          requests = fetchURLs.map(function (fetchURL) {\n            return fetchFunc(fetchURL, loadOptions.requestInit, {\n              isBinary: true\n            });\n          });\n          fetchStartFraction = 0;\n          fetchEndFraction = 0.5;\n          if (!(loadOptions.onProgress == null)) return [3\n          /*break*/\n          , 2];\n          return [4\n          /*yield*/\n          , Promise.all(requests)];\n\n        case 1:\n          _a = _c.sent();\n          return [3\n          /*break*/\n          , 4];\n\n        case 2:\n          return [4\n          /*yield*/\n          , progress_1.monitorPromisesProgress(requests, loadOptions.onProgress, fetchStartFraction, fetchEndFraction)];\n\n        case 3:\n          _a = _c.sent();\n          _c.label = 4;\n\n        case 4:\n          responses = _a;\n          bufferPromises = responses.map(function (response) {\n            return response.arrayBuffer();\n          });\n          bufferStartFraction = 0.5;\n          bufferEndFraction = 1;\n          if (!(loadOptions.onProgress == null)) return [3\n          /*break*/\n          , 6];\n          return [4\n          /*yield*/\n          , Promise.all(bufferPromises)];\n\n        case 5:\n          _b = _c.sent();\n          return [3\n          /*break*/\n          , 8];\n\n        case 6:\n          return [4\n          /*yield*/\n          , progress_1.monitorPromisesProgress(bufferPromises, loadOptions.onProgress, bufferStartFraction, bufferEndFraction)];\n\n        case 7:\n          _b = _c.sent();\n          _c.label = 8;\n\n        case 8:\n          buffers = _b;\n          return [2\n          /*return*/\n          , buffers];\n      }\n    });\n  });\n}\n\nexports.loadWeightsAsArrayBuffer = loadWeightsAsArrayBuffer;\n/**\n * Reads a weights manifest JSON configuration, fetches the weights and\n * returns them as `Tensor`s.\n *\n * @param manifest The weights manifest JSON.\n * @param filePathPrefix The path prefix for filenames given in the manifest.\n *     Defaults to the empty string.\n * @param weightNames The names of the weights to be fetched.\n */\n\nfunction loadWeights(manifest, filePathPrefix, weightNames, requestInit) {\n  if (filePathPrefix === void 0) {\n    filePathPrefix = '';\n  }\n\n  return __awaiter(this, void 0, void 0, function () {\n    var fetchWeights, loadWeights;\n    return __generator(this, function (_a) {\n      fetchWeights = function (fetchUrls) {\n        return loadWeightsAsArrayBuffer(fetchUrls, {\n          requestInit: requestInit\n        });\n      };\n\n      loadWeights = weightsLoaderFactory(fetchWeights);\n      return [2\n      /*return*/\n      , loadWeights(manifest, filePathPrefix, weightNames)];\n    });\n  });\n}\n\nexports.loadWeights = loadWeights;\n/**\n * Creates a function, which reads a weights manifest JSON configuration,\n * fetches the weight files using the specified function and returns them as\n * `Tensor`s.\n *\n * ```js\n * // example for creating a nodejs weight loader, which reads the weight files\n * // from disk using fs.readFileSync\n *\n * import * as fs from 'fs'\n *\n * const fetchWeightsFromDisk = (filePaths: string[]) =>\n *   filePaths.map(filePath => fs.readFileSync(filePath).buffer)\n *\n * const loadWeights = tf.io.weightsLoaderFactory(fetchWeightsFromDisk)\n *\n * const manifest = JSON.parse(\n *   fs.readFileSync('./my_model-weights_manifest').toString()\n * )\n * const weightMap = await loadWeights(manifest, './')\n * ```\n * @param fetchWeightsFunction The function used for fetching the weight files.\n * @returns Weight loading function.\n */\n\nfunction weightsLoaderFactory(fetchWeightsFunction) {\n  var _this = this;\n\n  return function (manifest, filePathPrefix, weightNames) {\n    if (filePathPrefix === void 0) {\n      filePathPrefix = '';\n    }\n\n    return __awaiter(_this, void 0, void 0, function () {\n      var groupIndicesToFetchMap, groupWeightsToFetch, weightsFound, allManifestWeightNames, weightsNotFound, groupIndicesToFetch, fetchUrls, buffers, weightsTensorMap, bufferIndexOffset;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            groupIndicesToFetchMap = manifest.map(function () {\n              return false;\n            });\n            groupWeightsToFetch = {};\n            weightsFound = weightNames != null ? weightNames.map(function () {\n              return false;\n            }) : [];\n            allManifestWeightNames = [];\n            manifest.forEach(function (manifestGroupConfig, groupIndex) {\n              var groupOffset = 0;\n              manifestGroupConfig.weights.forEach(function (weightsEntry) {\n                var rawDtype = 'quantization' in weightsEntry ? weightsEntry.quantization.dtype : weightsEntry.dtype;\n                var weightsBytes = types_1.DTYPE_VALUE_SIZE_MAP[rawDtype] * util.sizeFromShape(weightsEntry.shape);\n\n                var enqueueWeightsForFetchingFn = function () {\n                  groupIndicesToFetchMap[groupIndex] = true;\n\n                  if (groupWeightsToFetch[groupIndex] == null) {\n                    groupWeightsToFetch[groupIndex] = [];\n                  }\n\n                  groupWeightsToFetch[groupIndex].push({\n                    manifestEntry: weightsEntry,\n                    groupOffset: groupOffset,\n                    sizeBytes: weightsBytes\n                  });\n                };\n\n                if (weightNames != null) {\n                  weightNames.forEach(function (weightName, weightIndex) {\n                    if (weightName === weightsEntry.name) {\n                      enqueueWeightsForFetchingFn();\n                      weightsFound[weightIndex] = true;\n                    }\n                  });\n                } else {\n                  enqueueWeightsForFetchingFn();\n                }\n\n                allManifestWeightNames.push(weightsEntry.name);\n                groupOffset += weightsBytes;\n              });\n            });\n\n            if (!weightsFound.every(function (found) {\n              return found;\n            })) {\n              weightsNotFound = weightNames.filter(function (_, i) {\n                return !weightsFound[i];\n              });\n              throw new Error(\"Could not find weights in manifest with names: \" + (weightsNotFound.join(', ') + \". \\n\") + \"Manifest JSON has weights with names: \" + (allManifestWeightNames.join(', ') + \".\"));\n            }\n\n            groupIndicesToFetch = groupIndicesToFetchMap.reduce(function (accumulator, shouldFetch, i) {\n              if (shouldFetch) {\n                accumulator.push(i);\n              }\n\n              return accumulator;\n            }, []);\n            fetchUrls = [];\n            groupIndicesToFetch.forEach(function (i) {\n              manifest[i].paths.forEach(function (filepath) {\n                var fetchUrl = filePathPrefix + (!filePathPrefix.endsWith('/') ? '/' : '') + filepath;\n                fetchUrls.push(fetchUrl);\n              });\n            });\n            return [4\n            /*yield*/\n            , fetchWeightsFunction(fetchUrls)];\n\n          case 1:\n            buffers = _a.sent();\n            weightsTensorMap = {};\n            bufferIndexOffset = 0;\n            groupIndicesToFetch.forEach(function (i) {\n              var numBuffers = manifest[i].paths.length;\n              var groupBytes = 0;\n\n              for (var i_1 = 0; i_1 < numBuffers; i_1++) {\n                groupBytes += buffers[bufferIndexOffset + i_1].byteLength;\n              } // Create a buffer for the whole group.\n\n\n              var groupBuffer = new ArrayBuffer(groupBytes);\n              var groupByteBuffer = new Uint8Array(groupBuffer);\n              var groupBufferOffset = 0;\n\n              for (var i_2 = 0; i_2 < numBuffers; i_2++) {\n                var buffer = new Uint8Array(buffers[bufferIndexOffset + i_2]);\n                groupByteBuffer.set(buffer, groupBufferOffset);\n                groupBufferOffset += buffer.byteLength;\n              }\n\n              var weightsEntries = groupWeightsToFetch[i];\n              weightsEntries.forEach(function (weightsEntry) {\n                var byteBuffer = groupBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);\n                var nameToTensorMap = io_utils_1.decodeWeights(byteBuffer, [weightsEntry.manifestEntry]);\n\n                for (var name_1 in nameToTensorMap) {\n                  weightsTensorMap[name_1] = nameToTensorMap[name_1];\n                }\n              });\n              bufferIndexOffset += numBuffers;\n            });\n            return [2\n            /*return*/\n            , weightsTensorMap];\n        }\n      });\n    });\n  };\n}\n\nexports.weightsLoaderFactory = weightsLoaderFactory;","map":null,"metadata":{},"sourceType":"script"}