{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar engine_1 = require(\"./engine\");\n\nvar environment_1 = require(\"./environment\");\n\nvar tensor_1 = require(\"./tensor\");\n\nvar util_1 = require(\"./util\");\n\nfunction inferShape(val, dtype) {\n  var firstElem = val;\n\n  if (util_1.isTypedArray(val)) {\n    return dtype === 'string' ? [] : [val.length];\n  }\n\n  if (!Array.isArray(val)) {\n    return []; // Scalar.\n  }\n\n  var shape = [];\n\n  while (Array.isArray(firstElem) || util_1.isTypedArray(firstElem) && dtype !== 'string') {\n    shape.push(firstElem.length);\n    firstElem = firstElem[0];\n  }\n\n  if (Array.isArray(val) && environment_1.env().getBool('TENSORLIKE_CHECK_SHAPE_CONSISTENCY')) {\n    deepAssertShapeConsistency(val, shape, []);\n  }\n\n  return shape;\n}\n\nexports.inferShape = inferShape;\n\nfunction deepAssertShapeConsistency(val, shape, indices) {\n  indices = indices || [];\n\n  if (!Array.isArray(val) && !util_1.isTypedArray(val)) {\n    util_1.assert(shape.length === 0, function () {\n      return \"Element arr[\" + indices.join('][') + \"] is a primitive, \" + (\"but should be an array/TypedArray of \" + shape[0] + \" elements\");\n    });\n    return;\n  }\n\n  util_1.assert(shape.length > 0, function () {\n    return \"Element arr[\" + indices.join('][') + \"] should be a primitive, \" + (\"but is an array of \" + val.length + \" elements\");\n  });\n  util_1.assert(val.length === shape[0], function () {\n    return \"Element arr[\" + indices.join('][') + \"] should have \" + shape[0] + \" \" + (\"elements, but has \" + val.length + \" elements\");\n  });\n  var subShape = shape.slice(1);\n\n  for (var i = 0; i < val.length; ++i) {\n    deepAssertShapeConsistency(val[i], subShape, indices.concat(i));\n  }\n}\n\nfunction assertDtype(expectedDtype, actualDType, argName, functionName) {\n  if (expectedDtype == null) {\n    return;\n  }\n\n  if (expectedDtype !== 'numeric' && expectedDtype !== actualDType || expectedDtype === 'numeric' && actualDType === 'string') {\n    throw new Error(\"Argument '\" + argName + \"' passed to '\" + functionName + \"' must \" + (\"be \" + expectedDtype + \" tensor, but got \" + actualDType + \" tensor\"));\n  }\n}\n\nfunction convertToTensor(x, argName, functionName, parseAsDtype) {\n  if (parseAsDtype === void 0) {\n    parseAsDtype = 'numeric';\n  }\n\n  if (x instanceof tensor_1.Tensor) {\n    assertDtype(parseAsDtype, x.dtype, argName, functionName);\n    return x;\n  }\n\n  var inferredDtype = util_1.inferDtype(x); // If the user expects a bool/int/float, use that info to update the\n  // inferredDtype when it is not a string.\n\n  if (inferredDtype !== 'string' && ['bool', 'int32', 'float32'].indexOf(parseAsDtype) >= 0) {\n    inferredDtype = parseAsDtype;\n  }\n\n  assertDtype(parseAsDtype, inferredDtype, argName, functionName);\n\n  if (x == null || !util_1.isTypedArray(x) && !Array.isArray(x) && typeof x !== 'number' && typeof x !== 'boolean' && typeof x !== 'string') {\n    var type = x == null ? 'null' : x.constructor.name;\n    throw new Error(\"Argument '\" + argName + \"' passed to '\" + functionName + \"' must be a \" + (\"Tensor or TensorLike, but got '\" + type + \"'\"));\n  }\n\n  var inferredShape = inferShape(x, inferredDtype);\n\n  if (!util_1.isTypedArray(x) && !Array.isArray(x)) {\n    x = [x];\n  }\n\n  var skipTypedArray = true;\n  var values = inferredDtype !== 'string' ? util_1.toTypedArray(x, inferredDtype, environment_1.env().getBool('DEBUG')) : util_1.flatten(x, [], skipTypedArray);\n  return engine_1.ENGINE.makeTensor(values, inferredShape, inferredDtype);\n}\n\nexports.convertToTensor = convertToTensor;\n\nfunction convertToTensorArray(arg, argName, functionName, parseAsDtype) {\n  if (parseAsDtype === void 0) {\n    parseAsDtype = 'numeric';\n  }\n\n  if (!Array.isArray(arg)) {\n    throw new Error(\"Argument \" + argName + \" passed to \" + functionName + \" must be a \" + '`Tensor[]` or `TensorLike[]`');\n  }\n\n  var tensors = arg;\n  return tensors.map(function (t, i) {\n    return convertToTensor(t, argName + \"[\" + i + \"]\", functionName);\n  }, parseAsDtype);\n}\n\nexports.convertToTensorArray = convertToTensorArray;","map":null,"metadata":{},"sourceType":"script"}