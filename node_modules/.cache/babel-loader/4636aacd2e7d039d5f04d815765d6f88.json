{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar environment_1 = require(\"./environment\");\n\nvar kernel_registry_1 = require(\"./kernel_registry\");\n\nvar profiler_1 = require(\"./profiler\");\n\nvar tape_1 = require(\"./tape\");\n\nvar tensor_1 = require(\"./tensor\");\n\nvar tensor_util_1 = require(\"./tensor_util\");\n\nvar util = require(\"./util\");\n\nvar util_1 = require(\"./util\");\n\nvar EngineState =\n/** @class */\nfunction () {\n  function EngineState() {\n    // Public since optimizers will use it.\n    this.registeredVariables = {};\n    this.nextTapeNodeId = 0;\n    this.numBytes = 0;\n    this.numTensors = 0;\n    this.numStringTensors = 0;\n    this.numDataBuffers = 0; // Number of nested tf.grad() statements when computing higher-order\n    // gradients. E.g. `1` for first-order gradients and `2` for second-order\n    // gradients. Used to track if the tape should be removed after a backprop.\n\n    this.gradientDepth = 0; // Number of nested kernel calls. When kernel depth is greater than 1, we turn\n    // off the tape.\n\n    this.kernelDepth = 0;\n    this.scopeStack = [];\n    /**\n     * Keeps track of the number of data moves during a kernel execution. We\n     * maintain a stack since kernels can call other kernels, recursively.\n     */\n\n    this.numDataMovesStack = [];\n    this.nextScopeId = 0;\n    this.tensorInfo = new WeakMap();\n    this.profiling = false;\n    this.activeProfile = {\n      newBytes: 0,\n      newTensors: 0,\n      peakBytes: 0,\n      kernels: [],\n      result: null\n    };\n  }\n\n  EngineState.prototype.dispose = function () {\n    for (var variableName in this.registeredVariables) {\n      this.registeredVariables[variableName].dispose();\n    }\n  };\n\n  return EngineState;\n}();\n\nvar Engine =\n/** @class */\nfunction () {\n  function Engine(ENV) {\n    this.ENV = ENV;\n    this.registry = {};\n    this.registryFactory = {};\n    this.pendingBackendInitId = 0;\n    this.state = new EngineState();\n  }\n\n  Engine.prototype.ready = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var sortedBackends, i, backendName, success;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.pendingBackendInit != null) {\n              return [2\n              /*return*/\n              , this.pendingBackendInit.then(function () {})];\n            }\n\n            if (this.backendInstance != null) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            sortedBackends = this.getSortedBackends();\n            i = 0;\n            _a.label = 1;\n\n          case 1:\n            if (!(i < sortedBackends.length)) return [3\n            /*break*/\n            , 5];\n            backendName = sortedBackends[i];\n            return [4\n            /*yield*/\n            , this.initializeBackend(backendName).success];\n\n          case 2:\n            success = _a.sent();\n            if (!success) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , this.setBackend(backendName)];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n\n          case 4:\n            i++;\n            return [3\n            /*break*/\n            , 1];\n\n          case 5:\n            throw new Error(\"Could not initialize any backends, all backend initializations \" + \"failed.\");\n        }\n      });\n    });\n  };\n\n  Object.defineProperty(Engine.prototype, \"backend\", {\n    get: function () {\n      if (this.pendingBackendInit != null) {\n        throw new Error(\"Backend '\" + this.backendName + \"' has not yet been initialized. Make \" + \"sure to await tf.ready() before calling other methods\");\n      }\n\n      if (this.backendInstance == null) {\n        var _a = this.initializeBackendsAndReturnBest(),\n            name_1 = _a.name,\n            asyncInit = _a.asyncInit;\n\n        if (asyncInit) {\n          throw new Error(\"The highest priority backend '\" + name_1 + \"' has not yet been \" + \"initialized. Make sure to await tf.ready() before calling \" + \"other methods\");\n        }\n\n        this.setBackend(name_1);\n      }\n\n      return this.backendInstance;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Engine.prototype.backendNames = function () {\n    return Object.keys(this.registryFactory);\n  };\n\n  Engine.prototype.findBackend = function (backendName) {\n    if (!(backendName in this.registry)) {\n      // If the backend hasn't been initialized but we have a registry entry for\n      // it, initialize it and return it.\n      if (backendName in this.registryFactory) {\n        var asyncInit = this.initializeBackend(backendName).asyncInit;\n\n        if (asyncInit) {\n          // Backend is not ready yet.\n          return null;\n        }\n      } else {\n        return null;\n      }\n    }\n\n    return this.registry[backendName];\n  };\n\n  Engine.prototype.findBackendFactory = function (backendName) {\n    if (!(backendName in this.registryFactory)) {\n      return null;\n    }\n\n    return this.registryFactory[backendName].factory;\n  };\n\n  Engine.prototype.registerBackend = function (backendName, factory, priority) {\n    if (priority === void 0) {\n      priority = 1;\n    }\n\n    if (backendName in this.registryFactory) {\n      console.warn(backendName + \" backend was already registered. \" + \"Reusing existing backend factory.\");\n      return false;\n    }\n\n    this.registryFactory[backendName] = {\n      factory: factory,\n      priority: priority\n    };\n    return true;\n  };\n\n  Engine.prototype.setBackend = function (backendName) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, success, asyncInit, result, _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (this.registryFactory[backendName] == null) {\n              throw new Error(\"Backend name '\" + backendName + \"' not found in registry\");\n            }\n\n            this.backendName = backendName;\n            if (!(this.registry[backendName] == null)) return [3\n            /*break*/\n            , 4];\n            this.backendInstance = null;\n            _a = this.initializeBackend(backendName), success = _a.success, asyncInit = _a.asyncInit;\n            if (!asyncInit) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , success];\n\n          case 1:\n            _b = _c.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            _b = success;\n            _c.label = 3;\n\n          case 3:\n            result = _b;\n\n            if (!result) {\n              return [2\n              /*return*/\n              , false];\n            }\n\n            _c.label = 4;\n\n          case 4:\n            this.backendInstance = this.registry[backendName];\n            this.setupRegisteredKernels(); // Reset the profiler.\n\n            this.profiler = new profiler_1.Profiler(this.backendInstance);\n            return [2\n            /*return*/\n            , true];\n        }\n      });\n    });\n  };\n\n  Engine.prototype.setupRegisteredKernels = function () {\n    var _this = this;\n\n    var kernels = kernel_registry_1.getKernelsForBackend(this.backendName);\n    kernels.forEach(function (kernel) {\n      if (kernel.setupFunc != null) {\n        kernel.setupFunc(_this.backendInstance);\n      }\n    });\n  };\n\n  Engine.prototype.disposeRegisteredKernels = function (backendName) {\n    var _this = this;\n\n    var kernels = kernel_registry_1.getKernelsForBackend(backendName);\n    kernels.forEach(function (kernel) {\n      if (kernel.disposeFunc != null) {\n        kernel.disposeFunc(_this.registry[backendName]);\n      }\n    });\n  };\n  /**\n   * Initializes a backend by looking up the backend name in the factory\n   * registry and calling the factory method. Returns a boolean representing\n   * whether the initialization of the backend suceeded. Throws an error if\n   * there is no backend in the factory registry.\n   */\n\n\n  Engine.prototype.initializeBackend = function (backendName) {\n    var _this = this;\n\n    var registryFactoryEntry = this.registryFactory[backendName];\n\n    if (registryFactoryEntry == null) {\n      throw new Error(\"Cannot initialize backend \" + backendName + \", no registration found.\");\n    }\n\n    try {\n      var backend = registryFactoryEntry.factory(); // Test if the factory returns a promise.\n\n      if (Promise.resolve(backend) === backend) {\n        var promiseId_1 = ++this.pendingBackendInitId;\n        var success = backend.then(function (backendInstance) {\n          // Outdated promise. Another backend was set in the meantime.\n          if (promiseId_1 < _this.pendingBackendInitId) {\n            return false;\n          }\n\n          _this.registry[backendName] = backendInstance;\n          _this.pendingBackendInit = null;\n          return true;\n        }).catch(function (err) {\n          // Outdated promise. Another backend was set in the meantime.\n          if (promiseId_1 < _this.pendingBackendInitId) {\n            return false;\n          }\n\n          _this.pendingBackendInit = null;\n          console.warn(\"Initialization of backend \" + backendName + \" failed\");\n          console.warn(err.stack || err.message);\n          return false;\n        });\n        this.pendingBackendInit = success;\n        return {\n          success: success,\n          asyncInit: true\n        };\n      } else {\n        this.registry[backendName] = backend;\n        return {\n          success: true,\n          asyncInit: false\n        };\n      }\n    } catch (err) {\n      console.warn(\"Initialization of backend \" + backendName + \" failed\");\n      console.warn(err.stack || err.message);\n      return {\n        success: false,\n        asyncInit: false\n      };\n    }\n  };\n\n  Engine.prototype.removeBackend = function (backendName) {\n    if (!(backendName in this.registryFactory)) {\n      throw new Error(backendName + \" backend not found in registry\");\n    }\n\n    if (this.backendName === backendName && this.pendingBackendInit != null) {\n      // There is a pending promise of the backend we want to remove. Make it\n      // obsolete.\n      this.pendingBackendInitId++;\n    }\n\n    if (backendName in this.registry) {\n      this.disposeRegisteredKernels(backendName);\n      this.registry[backendName].dispose();\n      delete this.registry[backendName];\n    }\n\n    delete this.registryFactory[backendName]; // Unset the backend if it is active.\n\n    if (this.backendName === backendName) {\n      this.pendingBackendInit = null;\n      this.backendName = null;\n      this.backendInstance = null;\n    }\n  };\n\n  Engine.prototype.getSortedBackends = function () {\n    var _this = this;\n\n    if (Object.keys(this.registryFactory).length === 0) {\n      throw new Error('No backend found in registry.');\n    }\n\n    return Object.keys(this.registryFactory).sort(function (a, b) {\n      // Highest priority comes first.\n      return _this.registryFactory[b].priority - _this.registryFactory[a].priority;\n    });\n  };\n\n  Engine.prototype.initializeBackendsAndReturnBest = function () {\n    var sortedBackends = this.getSortedBackends();\n\n    for (var i = 0; i < sortedBackends.length; i++) {\n      var backendName = sortedBackends[i];\n\n      var _a = this.initializeBackend(backendName),\n          success = _a.success,\n          asyncInit = _a.asyncInit;\n\n      if (asyncInit || success) {\n        return {\n          name: backendName,\n          asyncInit: asyncInit\n        };\n      }\n    }\n\n    throw new Error(\"Could not initialize any backends, all backend initializations \" + \"failed.\");\n  };\n\n  Engine.prototype.moveData = function (destBackend, dataId) {\n    var info = this.state.tensorInfo.get(dataId);\n    var srcBackend = info.backend;\n    var values = this.readSync(dataId); // Delete the tensor from the old backend and move it to the new\n    // backend.\n\n    srcBackend.disposeData(dataId);\n    info.backend = destBackend;\n    destBackend.move(dataId, values, info.shape, info.dtype);\n\n    if (this.shouldCheckForMemLeaks()) {\n      // Track the number of moves during a kernel execution to correctly\n      // detect memory leaks.\n      this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;\n    }\n  };\n\n  Engine.prototype.tidy = function (nameOrFn, fn) {\n    var _this = this;\n\n    var name = null;\n\n    if (fn == null) {\n      // Called with only 1 argument.\n      if (typeof nameOrFn !== 'function') {\n        throw new Error('Please provide a function to tidy()');\n      }\n\n      fn = nameOrFn;\n    } else {\n      // Called with 2 arguments.\n      if (typeof nameOrFn !== 'string' && !(nameOrFn instanceof String)) {\n        throw new Error('When calling with two arguments, the first argument ' + 'to tidy() must be a string');\n      }\n\n      if (typeof fn !== 'function') {\n        throw new Error('When calling with two arguments, the 2nd argument ' + 'to tidy() must be a function');\n      }\n\n      name = nameOrFn; // TODO(nsthorat,smilkov): Do operation logging and performance\n      // profiling.\n    }\n\n    var result;\n    return this.scopedRun(function () {\n      return _this.startScope(name);\n    }, function () {\n      return _this.endScope(result);\n    }, function () {\n      result = fn();\n\n      if (result instanceof Promise) {\n        console.error('Cannot return a Promise inside of tidy.');\n      }\n\n      return result;\n    });\n  };\n\n  Engine.prototype.scopedRun = function (start, end, f) {\n    start();\n\n    try {\n      var res = f();\n      end();\n      return res;\n    } catch (ex) {\n      end();\n      throw ex;\n    }\n  };\n\n  Engine.prototype.nextTensorId = function () {\n    return Engine.nextTensorId++;\n  };\n\n  Engine.prototype.nextVariableId = function () {\n    return Engine.nextVariableId++;\n  };\n  /**\n   * This method is called instead of the public-facing tensor.clone() when\n   * saving a tensor for backwards pass. It makes sure to add the clone\n   * operation to the tape regardless of being called inside a kernel\n   * execution.\n   *\n   * This method will go away once all kernels are modularized since we won't\n   * need to turn off the tape inside runKernel().\n   */\n\n\n  Engine.prototype.clone = function (x) {\n    var y = this.makeTensorFromDataId(x.dataId, x.shape, x.dtype);\n    var inputs = {\n      x: x\n    };\n\n    var grad = function (dy) {\n      return {\n        x: function () {\n          return dy.toFloat();\n        }\n      };\n    };\n\n    var saved = [];\n    this.addTapeNode(this.state.activeScope.name, inputs, [y], grad, saved);\n    return y;\n  };\n  /**\n   * Execute a kernel with the given name and return the output tensor.\n   *\n   * @param kernelName The name of the kernel to execute.\n   * @param inputs A map of input names to tensors.\n   * @param attrs A map of attribute names to their values. An attribute is a\n   *     primitive (non-tensor) input to the kernel.\n   * @param inputsToSave A list of tensors, inputs to save for the backprop\n   *     computation.\n   * @param outputsToSave A list of booleans, specifying which output to save\n   *     for the backprop computation. These are booleans since the output\n   * tensors are not visible to the user.\n   */\n\n\n  Engine.prototype.runKernel = function (kernelName, inputs, attrs, inputsToSave, outputsToSave) {\n    var forwardFunc = null;\n    var backwardsFunc = null; // Call runKernel as a stop-gap until we modularize all kernels.\n    // Once we modularize all kernels, we will remove the existing\n    // `runKernelFunc`.\n\n    return this.runKernelFunc(forwardFunc, inputs, backwardsFunc, kernelName, attrs, inputsToSave, outputsToSave);\n  };\n\n  Engine.prototype.shouldCheckForMemLeaks = function () {\n    return this.ENV.getBool('IS_TEST');\n  };\n\n  Engine.prototype.checkKernelForMemLeak = function (scopeName, numDataIdsBefore, outInfos) {\n    var numDataIdsAfter = this.backend.numDataIds(); // Count the number of data ids associated with the result of the kernel.\n\n    var numOutputDataIds = 0;\n    outInfos.forEach(function (info) {\n      // Complex numbers allocate 3 data ids, one for 'real', one for\n      // 'imaginary', and one for the container that holds the former two.\n      numOutputDataIds += info.dtype === 'complex64' ? 3 : 1;\n    }); // Account for the number of moves during kernel execution. A \"data move\"\n    // can happen in the middle of a kernel execution, placing a new (key,value)\n    // pair in the data storage. Since data moves have net zero effect (we\n    // always remove the data from the old backend), we have to cancel them out\n    // when detecting memory leaks.\n\n    var numMoves = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];\n    var dataIdsLeaked = numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;\n\n    if (dataIdsLeaked > 0) {\n      throw new Error(\"Backend '\" + this.backendName + \"' has an internal memory leak \" + (\"(\" + dataIdsLeaked + \" data ids) after running '\" + scopeName + \"'\"));\n    }\n  };\n  /**\n   * @deprecated Use `runKernel` for newly added kernels. Keep using this method\n   *     only for kernels that are not yet fully modularized.\n   */\n\n\n  Engine.prototype.runKernelFunc = function (forwardFunc, inputs, backwardsFunc, kernelName, attrs, inputsToSave, outputsToSave) {\n    var _this = this;\n\n    if (inputsToSave === void 0) {\n      inputsToSave = [];\n    }\n\n    if (outputsToSave === void 0) {\n      outputsToSave = [];\n    }\n\n    var outputs;\n    var saved = [];\n    var isTapeOn = this.isTapeOn();\n    var scopeName = this.state.activeScope != null ? this.state.activeScope.name : '';\n\n    var saveFunc = function (tensors) {\n      // Do not save unless we are recording to the tape. Otherwise it would\n      // cause a mem leak since we would never run backprop, which disposes\n      // the kept tensors.\n      if (!isTapeOn) {\n        return;\n      }\n\n      saved = tensors.map(function (tensor) {\n        return _this.keep(_this.clone(tensor));\n      });\n    };\n\n    var startingBytecount = this.state.numBytes;\n    var startingNumTensors = this.state.numTensors;\n\n    if (this.shouldCheckForMemLeaks()) {\n      this.state.numDataMovesStack.push(0);\n    }\n\n    var kernelFunc;\n    var kernel = kernel_registry_1.getKernel(kernelName, this.backendName);\n    var out;\n\n    if (kernel != null) {\n      kernelFunc = function () {\n        var numDataIdsBefore = _this.backend.numDataIds();\n\n        out = kernel.kernelFunc({\n          inputs: inputs,\n          attrs: attrs,\n          backend: _this.backend\n        });\n        var outInfos = Array.isArray(out) ? out : [out];\n\n        if (_this.shouldCheckForMemLeaks()) {\n          _this.checkKernelForMemLeak(scopeName, numDataIdsBefore, outInfos);\n        }\n\n        var outTensors = outInfos.map(function (_a) {\n          var dataId = _a.dataId,\n              shape = _a.shape,\n              dtype = _a.dtype;\n          return _this.makeTensorFromDataId(dataId, shape, dtype);\n        });\n        var outsToSave = outTensors.filter(function (_, i) {\n          return outputsToSave[i];\n        }); // Save the inputs and outputs.\n\n        saveFunc(inputsToSave.slice().concat(outsToSave));\n        return outTensors;\n      };\n    } else {\n      kernelFunc = function () {\n        var numDataIdsBefore = _this.backend.numDataIds();\n\n        out = _this.tidy(function () {\n          return forwardFunc(_this.backend, saveFunc);\n        });\n        var outs = Array.isArray(out) ? out : [out];\n\n        if (_this.shouldCheckForMemLeaks()) {\n          _this.checkKernelForMemLeak(scopeName, numDataIdsBefore, outs);\n        }\n\n        return outs;\n      };\n    } // Stop recording to a tape when running a kernel.\n\n\n    this.scopedRun(function () {\n      return _this.state.kernelDepth++;\n    }, function () {\n      return _this.state.kernelDepth--;\n    }, function () {\n      if (!_this.ENV.getBool('DEBUG')) {\n        outputs = kernelFunc();\n      } else {\n        outputs = _this.profiler.profileKernel(scopeName, inputs, function () {\n          return kernelFunc();\n        });\n      }\n    });\n\n    if (isTapeOn) {\n      this.addTapeNode(scopeName, inputs, outputs, backwardsFunc, saved);\n    }\n\n    if (this.state.profiling) {\n      this.state.activeProfile.kernels.push({\n        name: scopeName,\n        bytesAdded: this.state.numBytes - startingBytecount,\n        totalBytesSnapshot: this.state.numBytes,\n        tensorsAdded: this.state.numTensors - startingNumTensors,\n        totalTensorsSnapshot: this.state.numTensors,\n        inputShapes: Object.keys(inputs).map(function (key) {\n          return inputs[key].shape;\n        }),\n        outputShapes: outputs.map(function (item) {\n          return item.shape;\n        })\n      });\n    }\n\n    return Array.isArray(out) ? outputs : outputs[0];\n  };\n  /**\n   * Internal method used by public APIs for tensor creation. Makes a new\n   * tensor with the provided shape, dtype and values. It always\n   * creates a new data id and writes the values to the underlying backend.\n   */\n\n\n  Engine.prototype.makeTensor = function (values, shape, dtype, backend) {\n    if (values == null) {\n      throw new Error('Values passed to engine.makeTensor() are null');\n    }\n\n    dtype = dtype || 'float32';\n    backend = backend || this.backend;\n    var backendVals = values;\n\n    if (dtype === 'string' && util.isString(values[0])) {\n      backendVals = values.map(function (d) {\n        return util.encodeString(d);\n      });\n    }\n\n    var dataId = backend.write(backendVals, shape, dtype);\n    var t = new tensor_1.Tensor(shape, dtype, dataId, this.nextTensorId());\n    this.incRef(t, backend); // Count bytes for string tensors.\n\n    if (dtype === 'string') {\n      var info = this.state.tensorInfo.get(dataId);\n      var newBytes = util_1.bytesFromStringArray(backendVals);\n      this.state.numBytes += newBytes - info.bytes;\n      info.bytes = newBytes;\n    }\n\n    return t;\n  };\n  /**\n   * Internal method used by backends. Makes a new tensor\n   * that is a wrapper around an existing data id. It doesn't create\n   * a new data id, only increments the ref count used in memory tracking.\n   */\n\n\n  Engine.prototype.makeTensorFromDataId = function (dataId, shape, dtype, backend) {\n    dtype = dtype || 'float32';\n    var t = new tensor_1.Tensor(shape, dtype, dataId, this.nextTensorId());\n    this.incRef(t, backend);\n    return t;\n  };\n\n  Engine.prototype.makeVariable = function (initialValue, trainable, name, dtype) {\n    if (trainable === void 0) {\n      trainable = true;\n    }\n\n    name = name || this.nextVariableId().toString();\n\n    if (dtype != null && dtype !== initialValue.dtype) {\n      initialValue = initialValue.asType(dtype);\n    }\n\n    var v = new tensor_1.Variable(initialValue, trainable, name, this.nextTensorId());\n\n    if (this.state.registeredVariables[v.name] != null) {\n      throw new Error(\"Variable with name \" + v.name + \" was already registered\");\n    }\n\n    this.state.registeredVariables[v.name] = v;\n    this.incRef(v, this.backend);\n    return v;\n  };\n\n  Engine.prototype.incRef = function (a, backend) {\n    var refCount = this.state.tensorInfo.has(a.dataId) ? this.state.tensorInfo.get(a.dataId).refCount : 0;\n    this.state.numTensors++;\n\n    if (a.dtype === 'string') {\n      this.state.numStringTensors++;\n    }\n\n    if (refCount === 0) {\n      this.state.numDataBuffers++; // Bytes for complex numbers are counted by their components. Bytes for\n      // string tensors are counted when writing values.\n\n      var bytes = 0;\n\n      if (a.dtype !== 'complex64' && a.dtype !== 'string') {\n        bytes = a.size * util.bytesPerElement(a.dtype);\n      }\n\n      this.state.tensorInfo.set(a.dataId, {\n        backend: backend || this.backend,\n        dtype: a.dtype,\n        shape: a.shape,\n        bytes: bytes,\n        refCount: 0\n      });\n      this.state.numBytes += bytes;\n    }\n\n    this.state.tensorInfo.get(a.dataId).refCount++;\n\n    if (!(a instanceof tensor_1.Variable)) {\n      this.track(a);\n    }\n  };\n\n  Engine.prototype.disposeTensor = function (a) {\n    if (!this.state.tensorInfo.has(a.dataId)) {\n      return;\n    }\n\n    this.state.numTensors--;\n\n    if (a.dtype === 'string') {\n      this.state.numStringTensors--;\n    }\n\n    var info = this.state.tensorInfo.get(a.dataId);\n    var refCount = info.refCount;\n\n    if (refCount <= 1) {\n      // Don't count bytes for complex numbers as they are counted by their\n      // components.\n      if (a.dtype !== 'complex64') {\n        this.state.numBytes -= info.bytes;\n      }\n\n      this.state.numDataBuffers--;\n      info.backend.disposeData(a.dataId);\n      this.state.tensorInfo.delete(a.dataId);\n    } else {\n      this.state.tensorInfo.get(a.dataId).refCount--;\n    } // TODO(nsthorat): Construct an error and save the stack trace for\n    // debugging when in debug mode. Creating a stack trace is too expensive\n    // to do unconditionally.\n\n  };\n\n  Engine.prototype.disposeVariables = function () {\n    for (var varName in this.state.registeredVariables) {\n      var v = this.state.registeredVariables[varName];\n      this.disposeVariable(v);\n    }\n  };\n\n  Engine.prototype.disposeVariable = function (v) {\n    this.disposeTensor(v);\n\n    if (this.state.registeredVariables[v.name] != null) {\n      delete this.state.registeredVariables[v.name];\n    }\n  };\n\n  Engine.prototype.memory = function () {\n    var info = this.backend.memory();\n    info.numTensors = this.state.numTensors;\n    info.numDataBuffers = this.state.numDataBuffers;\n    info.numBytes = this.state.numBytes;\n\n    if (this.state.numStringTensors > 0) {\n      info.unreliable = true;\n\n      if (info.reasons == null) {\n        info.reasons = [];\n      }\n\n      info.reasons.push('Memory usage by string tensors is approximate ' + '(2 bytes per character)');\n    }\n\n    return info;\n  };\n\n  Engine.prototype.profile = function (query) {\n    return __awaiter(this, void 0, void 0, function () {\n      var startBytes, startNumTensors;\n      return __generator(this, function (_a) {\n        this.state.profiling = true;\n        startBytes = this.state.numBytes;\n        startNumTensors = this.state.numTensors;\n        this.state.activeProfile.kernels = [];\n        this.state.activeProfile.result = query();\n        this.state.profiling = false;\n        this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function (d) {\n          return d.totalBytesSnapshot;\n        }));\n        this.state.activeProfile.newBytes = this.state.numBytes - startBytes;\n        this.state.activeProfile.newTensors = this.state.numTensors - startNumTensors;\n        return [2\n        /*return*/\n        , this.state.activeProfile];\n      });\n    });\n  };\n\n  Engine.prototype.isTapeOn = function () {\n    return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;\n  };\n\n  Engine.prototype.addTapeNode = function (scopeName, inputs, outputs, gradientsFunc, saved) {\n    var _this = this;\n\n    var tapeNode = {\n      id: this.state.nextTapeNodeId++,\n      name: scopeName,\n      inputs: inputs,\n      outputs: outputs,\n      saved: saved\n    };\n\n    if (gradientsFunc != null) {\n      tapeNode.gradient = function (dys) {\n        // TODO(smilkov): To optimize back-prop, pass dys that are not used in\n        // the backprop graph to the user as null instead of zeros\n        dys = dys.map(function (dy, i) {\n          if (dy == null) {\n            var output = outputs[i];\n            var vals = util.makeZerosTypedArray(output.size, output.dtype);\n            return _this.makeTensor(vals, output.shape, output.dtype);\n          }\n\n          return dy;\n        }); // Grad functions of ops with single outputs expect a dy, while ops\n        // with multiple outputs expect dys (array of dy).\n\n        return gradientsFunc(dys.length > 1 ? dys : dys[0], saved);\n      };\n    }\n\n    this.state.activeTape.push(tapeNode);\n  };\n\n  Engine.prototype.keep = function (result) {\n    result.kept = true;\n    return result;\n  };\n\n  Engine.prototype.startTape = function () {\n    if (this.state.gradientDepth === 0) {\n      this.state.activeTape = [];\n    }\n\n    this.state.gradientDepth++;\n  };\n\n  Engine.prototype.endTape = function () {\n    this.state.gradientDepth--;\n  };\n  /**\n   * Start a scope. Use this with endScope() to achieve the same functionality\n   * as scope() without the need for a function closure.\n   */\n\n\n  Engine.prototype.startScope = function (name) {\n    var scopeInfo = {\n      track: [],\n      name: 'unnamed scope',\n      id: this.state.nextScopeId++\n    };\n\n    if (name) {\n      scopeInfo.name = name;\n    }\n\n    this.state.scopeStack.push(scopeInfo);\n    this.state.activeScope = scopeInfo;\n  };\n  /**\n   * End a scope. Use this with startScope() to achieve the same functionality\n   * as scope() without the need for a function closure.\n   */\n\n\n  Engine.prototype.endScope = function (result) {\n    var _this = this;\n\n    var tensorsToTrackInParent = tensor_util_1.getTensorsInContainer(result);\n    var tensorsToTrackInParentSet = new Set(tensorsToTrackInParent.map(function (t) {\n      return t.id;\n    })); // Dispose the arrays tracked in this scope.\n\n    for (var i = 0; i < this.state.activeScope.track.length; i++) {\n      var tensor = this.state.activeScope.track[i];\n\n      if (!tensor.kept && !tensorsToTrackInParentSet.has(tensor.id)) {\n        tensor.dispose();\n      }\n    }\n\n    var oldScope = this.state.scopeStack.pop();\n    this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1]; // Track the current result in the parent scope.\n\n    tensorsToTrackInParent.forEach(function (tensor) {\n      // Only track the tensor if was allocated in the inner scope and is not\n      // globally kept.\n      if (!tensor.kept && tensor.scopeId === oldScope.id) {\n        _this.track(tensor);\n      }\n    });\n  };\n  /**\n   * Returns gradients of `f` with respect to each of the `xs`. The gradients\n   * returned are of the same length as `xs`, but some might be null if `f`\n   * was not a function of that `x`. It also takes optional dy to multiply the\n   * gradient, which defaults to `1`.\n   */\n\n\n  Engine.prototype.gradients = function (f, xs, dy, allowNoGradients) {\n    var _this = this;\n\n    if (allowNoGradients === void 0) {\n      allowNoGradients = false;\n    }\n\n    util.assert(xs.length > 0, function () {\n      return 'gradients() received an empty list of xs.';\n    });\n\n    if (dy != null && dy.dtype !== 'float32') {\n      throw new Error(\"dy must have 'float32' dtype, but has '\" + dy.dtype + \"'\");\n    }\n\n    var y = this.scopedRun(function () {\n      return _this.startTape();\n    }, function () {\n      return _this.endTape();\n    }, function () {\n      return _this.tidy('forward', f);\n    });\n    util.assert(y instanceof tensor_1.Tensor, function () {\n      return 'The result y returned by f() must be a tensor.';\n    }); // Filter out the nodes that don't connect x => y.\n\n    var filteredTape = tape_1.getFilteredNodesXToY(this.state.activeTape, xs, y);\n\n    if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {\n      throw new Error('Cannot compute gradient of y=f(x) with respect to x. Make sure ' + 'that the f you passed encloses all operations that lead from x ' + 'to y.');\n    }\n\n    return this.tidy('backward', function () {\n      var accumulatedGradientMap = {};\n      accumulatedGradientMap[y.id] = dy == null ? ones(y.shape) : dy; // Backprop gradients through the filtered nodes.\n\n      tape_1.backpropagateGradients(accumulatedGradientMap, filteredTape, // Pass the tidy function to avoid circular dep with `tape.ts`.\n      function (f) {\n        return _this.tidy(f);\n      });\n      var grads = xs.map(function (x) {\n        return accumulatedGradientMap[x.id];\n      });\n\n      if (_this.state.gradientDepth === 0) {\n        // This means that we are not computing higher-order gradients\n        // and can clean up the tape.\n        _this.state.activeTape.forEach(function (node) {\n          for (var key in node.saved) {\n            node.saved[key].dispose();\n          }\n        });\n\n        _this.state.activeTape = null;\n      }\n\n      return {\n        value: y,\n        grads: grads\n      };\n    });\n  };\n\n  Engine.prototype.customGrad = function (f) {\n    var _this = this;\n\n    util.assert(util.isFunction(f), function () {\n      return 'The f passed in customGrad(f) must be a function.';\n    });\n    return function () {\n      var inputs = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        inputs[_i] = arguments[_i];\n      }\n\n      util.assert(inputs.every(function (t) {\n        return t instanceof tensor_1.Tensor;\n      }), function () {\n        return 'The args passed in customGrad(f)(x1, x2,...) must all be ' + 'tensors';\n      });\n      var res;\n      var inputMap = {};\n      inputs.forEach(function (input, i) {\n        inputMap[i] = input;\n      });\n      return _this.runKernelFunc(function (_, save) {\n        res = f.apply(void 0, inputs.concat([save]));\n        util.assert(res.value instanceof tensor_1.Tensor, function () {\n          return 'The function f passed in customGrad(f) must return an ' + 'object where `obj.value` is a tensor';\n        });\n        util.assert(util.isFunction(res.gradFunc), function () {\n          return 'The function f passed in customGrad(f) must return an ' + 'object where `obj.gradFunc` is a function.';\n        });\n        return res.value;\n      }, inputMap, function (dy, saved) {\n        var gradRes = res.gradFunc(dy, saved);\n        var grads = Array.isArray(gradRes) ? gradRes : [gradRes];\n        util.assert(grads.length === inputs.length, function () {\n          return 'The function f passed in customGrad(f) must return an ' + 'object where `obj.gradFunc` is a function that returns ' + 'the same number of tensors as inputs passed to f(...).';\n        });\n        util.assert(grads.every(function (t) {\n          return t instanceof tensor_1.Tensor;\n        }), function () {\n          return 'The function f passed in customGrad(f) must return an ' + 'object where `obj.gradFunc` is a function that returns ' + 'a list of only tensors.';\n        });\n        var gradMap = {};\n        grads.forEach(function (grad, i) {\n          gradMap[i] = function () {\n            return grad;\n          };\n        });\n        return gradMap;\n      });\n    };\n  };\n\n  Engine.prototype.readSync = function (dataId) {\n    // Route the read to the correct backend.\n    var info = this.state.tensorInfo.get(dataId);\n    return info.backend.readSync(dataId);\n  };\n\n  Engine.prototype.read = function (dataId) {\n    // Route the read to the correct backend.\n    var info = this.state.tensorInfo.get(dataId);\n    return info.backend.read(dataId);\n  };\n\n  Engine.prototype.fromPixels = function (pixels, numChannels) {\n    return this.backend.fromPixels(pixels, numChannels);\n  };\n\n  Engine.prototype.time = function (query) {\n    return __awaiter(this, void 0, void 0, function () {\n      var start, timingInfo;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            start = util_1.now();\n            return [4\n            /*yield*/\n            , this.backend.time(query)];\n\n          case 1:\n            timingInfo = _a.sent();\n            timingInfo.wallMs = util_1.now() - start;\n            return [2\n            /*return*/\n            , timingInfo];\n        }\n      });\n    });\n  };\n  /**\n   * Tracks a Tensor in the current scope to be automatically cleaned up\n   * when the current scope ends, and returns the value.\n   *\n   * @param result The Tensor to track in the current scope.\n   */\n\n\n  Engine.prototype.track = function (result) {\n    if (this.state.activeScope != null) {\n      result.scopeId = this.state.activeScope.id;\n      this.state.activeScope.track.push(result);\n    }\n\n    return result;\n  };\n\n  Object.defineProperty(Engine.prototype, \"registeredVariables\", {\n    get: function () {\n      return this.state.registeredVariables;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Resets the engine state. Removes all backends but does not remove\n   * registered backend factories.\n   */\n\n  Engine.prototype.reset = function () {\n    // Make any pending promise obsolete.\n    this.pendingBackendInitId++;\n    this.state.dispose();\n    this.ENV.reset();\n    this.state = new EngineState();\n\n    for (var backendName in this.registry) {\n      this.disposeRegisteredKernels(backendName);\n      this.registry[backendName].dispose();\n      delete this.registry[backendName];\n    }\n\n    this.backendName = null;\n    this.backendInstance = null;\n    this.pendingBackendInit = null;\n  };\n\n  Engine.nextTensorId = 0;\n  Engine.nextVariableId = 0;\n  return Engine;\n}();\n\nexports.Engine = Engine;\n\nfunction ones(shape) {\n  var values = util_1.makeOnesTypedArray(util_1.sizeFromShape(shape), 'float32');\n  return exports.ENGINE.makeTensor(values, shape, 'float32');\n}\n\nvar GLOBAL;\n\nfunction getGlobalNamespace() {\n  if (GLOBAL == null) {\n    // tslint:disable-next-line:no-any\n    var ns = void 0;\n\n    if (typeof window !== 'undefined') {\n      ns = window;\n    } else if (typeof global !== 'undefined') {\n      ns = global;\n    } else if (typeof process !== 'undefined') {\n      ns = process;\n    } else if (typeof self !== 'undefined') {\n      ns = self;\n    } else {\n      throw new Error('Could not find a global object');\n    }\n\n    GLOBAL = ns;\n  }\n\n  return GLOBAL;\n}\n\nfunction getOrMakeEngine() {\n  var ns = getGlobalNamespace();\n\n  if (ns._tfengine == null) {\n    var environment = new environment_1.Environment(ns);\n    ns._tfengine = new Engine(environment);\n  }\n\n  environment_1.setEnvironmentGlobal(ns._tfengine.ENV); // Tell the current tensor interface that the global engine is responsible\n  // for tracking.\n\n  tensor_1.setTensorTracker(function () {\n    return ns._tfengine;\n  });\n  return ns._tfengine;\n}\n\nexports.ENGINE = getOrMakeEngine();","map":null,"metadata":{},"sourceType":"script"}