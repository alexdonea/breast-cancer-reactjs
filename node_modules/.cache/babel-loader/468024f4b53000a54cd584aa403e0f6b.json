{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar environment_1 = require(\"../environment\");\n\nvar io_utils_1 = require(\"./io_utils\");\n\nvar model_management_1 = require(\"./model_management\");\n\nvar router_registry_1 = require(\"./router_registry\");\n\nvar DATABASE_NAME = 'tensorflowjs';\nvar DATABASE_VERSION = 1; // Model data and ModelArtifactsInfo (metadata) are stored in two separate\n// stores for efficient access of the list of stored models and their metadata.\n// 1. The object store for model data: topology, weights and weight manifests.\n\nvar MODEL_STORE_NAME = 'models_store'; // 2. The object store for ModelArtifactsInfo, including meta-information such\n//    as the type of topology (JSON vs binary), byte size of the topology, byte\n//    size of the weights, etc.\n\nvar INFO_STORE_NAME = 'model_info_store';\n/**\n * Delete the entire database for tensorflow.js, including the models store.\n */\n\nfunction deleteDatabase() {\n  return __awaiter(this, void 0, void 0, function () {\n    var idbFactory;\n    return __generator(this, function (_a) {\n      idbFactory = getIndexedDBFactory();\n      return [2\n      /*return*/\n      , new Promise(function (resolve, reject) {\n        var deleteRequest = idbFactory.deleteDatabase(DATABASE_NAME);\n\n        deleteRequest.onsuccess = function () {\n          return resolve();\n        };\n\n        deleteRequest.onerror = function (error) {\n          return reject(error);\n        };\n      })];\n    });\n  });\n}\n\nexports.deleteDatabase = deleteDatabase;\n\nfunction getIndexedDBFactory() {\n  if (!environment_1.env().getBool('IS_BROWSER')) {\n    // TODO(cais): Add more info about what IOHandler subtypes are available.\n    //   Maybe point to a doc page on the web and/or automatically determine\n    //   the available IOHandlers and print them in the error message.\n    throw new Error('Failed to obtain IndexedDB factory because the current environment' + 'is not a web browser.');\n  } // tslint:disable-next-line:no-any\n\n\n  var theWindow = window;\n  var factory = theWindow.indexedDB || theWindow.mozIndexedDB || theWindow.webkitIndexedDB || theWindow.msIndexedDB || theWindow.shimIndexedDB;\n\n  if (factory == null) {\n    throw new Error('The current browser does not appear to support IndexedDB.');\n  }\n\n  return factory;\n}\n\nfunction setUpDatabase(openRequest) {\n  var db = openRequest.result;\n  db.createObjectStore(MODEL_STORE_NAME, {\n    keyPath: 'modelPath'\n  });\n  db.createObjectStore(INFO_STORE_NAME, {\n    keyPath: 'modelPath'\n  });\n}\n/**\n * IOHandler subclass: Browser IndexedDB.\n *\n * See the doc string of `browserIndexedDB` for more details.\n */\n\n\nvar BrowserIndexedDB =\n/** @class */\nfunction () {\n  function BrowserIndexedDB(modelPath) {\n    this.indexedDB = getIndexedDBFactory();\n\n    if (modelPath == null || !modelPath) {\n      throw new Error('For IndexedDB, modelPath must not be null, undefined or empty.');\n    }\n\n    this.modelPath = modelPath;\n  }\n\n  BrowserIndexedDB.prototype.save = function (modelArtifacts) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        // TODO(cais): Support saving GraphDef models.\n        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n          throw new Error('BrowserLocalStorage.save() does not support saving model topology ' + 'in binary formats yet.');\n        }\n\n        return [2\n        /*return*/\n        , this.databaseAction(this.modelPath, modelArtifacts)];\n      });\n    });\n  };\n\n  BrowserIndexedDB.prototype.load = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.databaseAction(this.modelPath)];\n      });\n    });\n  };\n  /**\n   * Perform database action to put model artifacts into or read model artifacts\n   * from IndexedDB object store.\n   *\n   * Whether the action is put or get depends on whether `modelArtifacts` is\n   * specified. If it is specified, the action will be put; otherwise the action\n   * will be get.\n   *\n   * @param modelPath A unique string path for the model.\n   * @param modelArtifacts If specified, it will be the model artifacts to be\n   *   stored in IndexedDB.\n   * @returns A `Promise` of `SaveResult`, if the action is put, or a `Promise`\n   *   of `ModelArtifacts`, if the action is get.\n   */\n\n\n  BrowserIndexedDB.prototype.databaseAction = function (modelPath, modelArtifacts) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var openRequest = _this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n\n      openRequest.onupgradeneeded = function () {\n        return setUpDatabase(openRequest);\n      };\n\n      openRequest.onsuccess = function () {\n        var db = openRequest.result;\n\n        if (modelArtifacts == null) {\n          // Read model out from object store.\n          var modelTx = db.transaction(MODEL_STORE_NAME, 'readonly');\n          var modelStore = modelTx.objectStore(MODEL_STORE_NAME);\n          var getRequest_1 = modelStore.get(_this.modelPath);\n\n          getRequest_1.onsuccess = function () {\n            if (getRequest_1.result == null) {\n              db.close();\n              return reject(new Error(\"Cannot find model with path '\" + _this.modelPath + \"' \" + \"in IndexedDB.\"));\n            } else {\n              resolve(getRequest_1.result.modelArtifacts);\n            }\n          };\n\n          getRequest_1.onerror = function (error) {\n            db.close();\n            return reject(getRequest_1.error);\n          };\n\n          modelTx.oncomplete = function () {\n            return db.close();\n          };\n        } else {\n          // Put model into object store.\n          var modelArtifactsInfo_1 = io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts); // First, put ModelArtifactsInfo into info store.\n\n          var infoTx_1 = db.transaction(INFO_STORE_NAME, 'readwrite');\n          var infoStore_1 = infoTx_1.objectStore(INFO_STORE_NAME);\n          var putInfoRequest_1 = infoStore_1.put({\n            modelPath: _this.modelPath,\n            modelArtifactsInfo: modelArtifactsInfo_1\n          });\n          var modelTx_1;\n\n          putInfoRequest_1.onsuccess = function () {\n            // Second, put model data into model store.\n            modelTx_1 = db.transaction(MODEL_STORE_NAME, 'readwrite');\n            var modelStore = modelTx_1.objectStore(MODEL_STORE_NAME);\n            var putModelRequest = modelStore.put({\n              modelPath: _this.modelPath,\n              modelArtifacts: modelArtifacts,\n              modelArtifactsInfo: modelArtifactsInfo_1\n            });\n\n            putModelRequest.onsuccess = function () {\n              return resolve({\n                modelArtifactsInfo: modelArtifactsInfo_1\n              });\n            };\n\n            putModelRequest.onerror = function (error) {\n              // If the put-model request fails, roll back the info entry as\n              // well.\n              infoStore_1 = infoTx_1.objectStore(INFO_STORE_NAME);\n              var deleteInfoRequest = infoStore_1.delete(_this.modelPath);\n\n              deleteInfoRequest.onsuccess = function () {\n                db.close();\n                return reject(putModelRequest.error);\n              };\n\n              deleteInfoRequest.onerror = function (error) {\n                db.close();\n                return reject(putModelRequest.error);\n              };\n            };\n          };\n\n          putInfoRequest_1.onerror = function (error) {\n            db.close();\n            return reject(putInfoRequest_1.error);\n          };\n\n          infoTx_1.oncomplete = function () {\n            if (modelTx_1 == null) {\n              db.close();\n            } else {\n              modelTx_1.oncomplete = function () {\n                return db.close();\n              };\n            }\n          };\n        }\n      };\n\n      openRequest.onerror = function (error) {\n        return reject(openRequest.error);\n      };\n    });\n  };\n\n  BrowserIndexedDB.URL_SCHEME = 'indexeddb://';\n  return BrowserIndexedDB;\n}();\n\nexports.BrowserIndexedDB = BrowserIndexedDB;\n\nexports.indexedDBRouter = function (url) {\n  if (!environment_1.env().getBool('IS_BROWSER')) {\n    return null;\n  } else {\n    if (!Array.isArray(url) && url.startsWith(BrowserIndexedDB.URL_SCHEME)) {\n      return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));\n    } else {\n      return null;\n    }\n  }\n};\n\nrouter_registry_1.IORouterRegistry.registerSaveRouter(exports.indexedDBRouter);\nrouter_registry_1.IORouterRegistry.registerLoadRouter(exports.indexedDBRouter);\n/**\n * Creates a browser IndexedDB IOHandler for saving and loading models.\n *\n * ```js\n * const model = tf.sequential();\n * model.add(\n *     tf.layers.dense({units: 1, inputShape: [100], activation: 'sigmoid'}));\n *\n * const saveResult = await model.save('indexeddb://MyModel'));\n * console.log(saveResult);\n * ```\n *\n * @param modelPath A unique identifier for the model to be saved. Must be a\n *   non-empty string.\n * @returns An instance of `BrowserIndexedDB` (sublcass of `IOHandler`),\n *   which can be used with, e.g., `tf.Model.save`.\n */\n\nfunction browserIndexedDB(modelPath) {\n  return new BrowserIndexedDB(modelPath);\n}\n\nexports.browserIndexedDB = browserIndexedDB;\n\nfunction maybeStripScheme(key) {\n  return key.startsWith(BrowserIndexedDB.URL_SCHEME) ? key.slice(BrowserIndexedDB.URL_SCHEME.length) : key;\n}\n\nvar BrowserIndexedDBManager =\n/** @class */\nfunction () {\n  function BrowserIndexedDBManager() {\n    this.indexedDB = getIndexedDBFactory();\n  }\n\n  BrowserIndexedDBManager.prototype.listModels = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var openRequest = _this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n\n          openRequest.onupgradeneeded = function () {\n            return setUpDatabase(openRequest);\n          };\n\n          openRequest.onsuccess = function () {\n            var db = openRequest.result;\n            var tx = db.transaction(INFO_STORE_NAME, 'readonly');\n            var store = tx.objectStore(INFO_STORE_NAME); // tslint:disable:max-line-length\n            // Need to cast `store` as `any` here because TypeScript's DOM\n            // library does not have the `getAll()` method even though the\n            // method is supported in the latest version of most mainstream\n            // browsers:\n            // https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n            // tslint:enable:max-line-length\n            // tslint:disable-next-line:no-any\n\n            var getAllInfoRequest = store.getAll();\n\n            getAllInfoRequest.onsuccess = function () {\n              var out = {};\n\n              for (var _i = 0, _a = getAllInfoRequest.result; _i < _a.length; _i++) {\n                var item = _a[_i];\n                out[item.modelPath] = item.modelArtifactsInfo;\n              }\n\n              resolve(out);\n            };\n\n            getAllInfoRequest.onerror = function (error) {\n              db.close();\n              return reject(getAllInfoRequest.error);\n            };\n\n            tx.oncomplete = function () {\n              return db.close();\n            };\n          };\n\n          openRequest.onerror = function (error) {\n            return reject(openRequest.error);\n          };\n        })];\n      });\n    });\n  };\n\n  BrowserIndexedDBManager.prototype.removeModel = function (path) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        path = maybeStripScheme(path);\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var openRequest = _this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n\n          openRequest.onupgradeneeded = function () {\n            return setUpDatabase(openRequest);\n          };\n\n          openRequest.onsuccess = function () {\n            var db = openRequest.result;\n            var infoTx = db.transaction(INFO_STORE_NAME, 'readwrite');\n            var infoStore = infoTx.objectStore(INFO_STORE_NAME);\n            var getInfoRequest = infoStore.get(path);\n            var modelTx;\n\n            getInfoRequest.onsuccess = function () {\n              if (getInfoRequest.result == null) {\n                db.close();\n                return reject(new Error(\"Cannot find model with path '\" + path + \"' \" + \"in IndexedDB.\"));\n              } else {\n                // First, delete the entry in the info store.\n                var deleteInfoRequest = infoStore.delete(path);\n\n                var deleteModelData_1 = function () {\n                  // Second, delete the entry in the model store.\n                  modelTx = db.transaction(MODEL_STORE_NAME, 'readwrite');\n                  var modelStore = modelTx.objectStore(MODEL_STORE_NAME);\n                  var deleteModelRequest = modelStore.delete(path);\n\n                  deleteModelRequest.onsuccess = function () {\n                    return resolve(getInfoRequest.result.modelArtifactsInfo);\n                  };\n\n                  deleteModelRequest.onerror = function (error) {\n                    return reject(getInfoRequest.error);\n                  };\n                }; // Proceed with deleting model data regardless of whether deletion\n                // of info data succeeds or not.\n\n\n                deleteInfoRequest.onsuccess = deleteModelData_1;\n\n                deleteInfoRequest.onerror = function (error) {\n                  deleteModelData_1();\n                  db.close();\n                  return reject(getInfoRequest.error);\n                };\n              }\n            };\n\n            getInfoRequest.onerror = function (error) {\n              db.close();\n              return reject(getInfoRequest.error);\n            };\n\n            infoTx.oncomplete = function () {\n              if (modelTx == null) {\n                db.close();\n              } else {\n                modelTx.oncomplete = function () {\n                  return db.close();\n                };\n              }\n            };\n          };\n\n          openRequest.onerror = function (error) {\n            return reject(openRequest.error);\n          };\n        })];\n      });\n    });\n  };\n\n  return BrowserIndexedDBManager;\n}();\n\nexports.BrowserIndexedDBManager = BrowserIndexedDBManager;\n\nif (environment_1.env().getBool('IS_BROWSER')) {\n  // Wrap the construction and registration, to guard against browsers that\n  // don't support Local Storage.\n  try {\n    model_management_1.ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME, new BrowserIndexedDBManager());\n  } catch (err) {}\n}","map":null,"metadata":{},"sourceType":"script"}