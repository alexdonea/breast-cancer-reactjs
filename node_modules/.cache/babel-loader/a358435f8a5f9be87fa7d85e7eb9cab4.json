{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * IOHandler implementations based on HTTP requests in the web browser.\n *\n * Uses [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n */\n\nvar environment_1 = require(\"../environment\");\n\nvar util_1 = require(\"../util\");\n\nvar io_utils_1 = require(\"./io_utils\");\n\nvar router_registry_1 = require(\"./router_registry\");\n\nvar weights_loader_1 = require(\"./weights_loader\");\n\nvar OCTET_STREAM_MIME_TYPE = 'application/octet-stream';\nvar JSON_TYPE = 'application/json';\n\nvar HTTPRequest =\n/** @class */\nfunction () {\n  function HTTPRequest(path, loadOptions) {\n    this.DEFAULT_METHOD = 'POST';\n\n    if (loadOptions == null) {\n      loadOptions = {};\n    }\n\n    this.weightPathPrefix = loadOptions.weightPathPrefix;\n    this.onProgress = loadOptions.onProgress;\n\n    if (loadOptions.fetchFunc != null) {\n      util_1.assert(typeof loadOptions.fetchFunc === 'function', function () {\n        return 'Must pass a function that matches the signature of ' + '`fetch` (see ' + 'https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)';\n      });\n      this.fetch = loadOptions.fetchFunc;\n    } else {\n      this.fetch = environment_1.env().platform.fetch;\n    }\n\n    util_1.assert(path != null && path.length > 0, function () {\n      return 'URL path for http must not be null, undefined or ' + 'empty.';\n    });\n\n    if (Array.isArray(path)) {\n      util_1.assert(path.length === 2, function () {\n        return 'URL paths for http must have a length of 2, ' + (\"(actual length is \" + path.length + \").\");\n      });\n    }\n\n    this.path = path;\n\n    if (loadOptions.requestInit != null && loadOptions.requestInit.body != null) {\n      throw new Error('requestInit is expected to have no pre-existing body, but has one.');\n    }\n\n    this.requestInit = loadOptions.requestInit || {};\n  }\n\n  HTTPRequest.prototype.save = function (modelArtifacts) {\n    return __awaiter(this, void 0, void 0, function () {\n      var init, weightsManifest, modelTopologyAndWeightManifest, response;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n              throw new Error('BrowserHTTPRequest.save() does not support saving model topology ' + 'in binary formats yet.');\n            }\n\n            init = Object.assign({\n              method: this.DEFAULT_METHOD\n            }, this.requestInit);\n            init.body = new FormData();\n            weightsManifest = [{\n              paths: ['./model.weights.bin'],\n              weights: modelArtifacts.weightSpecs\n            }];\n            modelTopologyAndWeightManifest = {\n              modelTopology: modelArtifacts.modelTopology,\n              format: modelArtifacts.format,\n              generatedBy: modelArtifacts.generatedBy,\n              convertedBy: modelArtifacts.convertedBy,\n              userDefinedMetadata: modelArtifacts.userDefinedMetadata,\n              weightsManifest: weightsManifest\n            };\n            init.body.append('model.json', new Blob([JSON.stringify(modelTopologyAndWeightManifest)], {\n              type: JSON_TYPE\n            }), 'model.json');\n\n            if (modelArtifacts.weightData != null) {\n              init.body.append('model.weights.bin', new Blob([modelArtifacts.weightData], {\n                type: OCTET_STREAM_MIME_TYPE\n              }), 'model.weights.bin');\n            }\n\n            return [4\n            /*yield*/\n            , this.fetch(this.path, init)];\n\n          case 1:\n            response = _a.sent();\n\n            if (response.ok) {\n              return [2\n              /*return*/\n              , {\n                modelArtifactsInfo: io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts),\n                responses: [response]\n              }];\n            } else {\n              throw new Error(\"BrowserHTTPRequest.save() failed due to HTTP response status \" + (response.status + \".\"));\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Load model artifacts via HTTP request(s).\n   *\n   * See the documentation to `tf.io.http` for details on the saved\n   * artifacts.\n   *\n   * @returns The loaded model artifacts (if loading succeeds).\n   */\n\n\n  HTTPRequest.prototype.load = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var modelConfigRequest, modelConfig, e_1, message, modelTopology, weightsManifest, weightSpecs, weightData, results;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.fetch(this.path, this.requestInit)];\n\n          case 1:\n            modelConfigRequest = _a.sent();\n\n            if (!modelConfigRequest.ok) {\n              throw new Error(\"Request to \" + this.path + \" failed with status code \" + (modelConfigRequest.status + \". Please verify this URL points to \") + \"the model JSON of the model to load.\");\n            }\n\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , modelConfigRequest.json()];\n\n          case 3:\n            modelConfig = _a.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            e_1 = _a.sent();\n            message = \"Failed to parse model JSON of response from \" + this.path + \".\"; // TODO(nsthorat): Remove this after some time when we're comfortable that\n            // .pb files are mostly gone.\n\n            if (this.path.endsWith('.pb')) {\n              message += ' Your path contains a .pb file extension. ' + 'Support for .pb models have been removed in TensorFlow.js 1.0 ' + 'in favor of .json models. You can re-convert your Python ' + 'TensorFlow model using the TensorFlow.js 1.0 conversion scripts ' + 'or you can convert your.pb models with the \\'pb2json\\'' + 'NPM script in the tensorflow/tfjs-converter repository.';\n            } else {\n              message += ' Please make sure the server is serving valid ' + 'JSON for this request.';\n            }\n\n            throw new Error(message);\n\n          case 5:\n            modelTopology = modelConfig.modelTopology;\n            weightsManifest = modelConfig.weightsManifest; // We do not allow both modelTopology and weightsManifest to be missing.\n\n            if (modelTopology == null && weightsManifest == null) {\n              throw new Error(\"The JSON from HTTP path \" + this.path + \" contains neither model \" + \"topology or manifest for weights.\");\n            }\n\n            if (!(weightsManifest != null)) return [3\n            /*break*/\n            , 7];\n            return [4\n            /*yield*/\n            , this.loadWeights(weightsManifest)];\n\n          case 6:\n            results = _a.sent();\n            weightSpecs = results[0], weightData = results[1];\n            _a.label = 7;\n\n          case 7:\n            return [2\n            /*return*/\n            , {\n              modelTopology: modelTopology,\n              weightSpecs: weightSpecs,\n              weightData: weightData\n            }];\n        }\n      });\n    });\n  };\n\n  HTTPRequest.prototype.loadWeights = function (weightsManifest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var weightPath, _a, prefix, suffix, pathPrefix, weightSpecs, _i, weightsManifest_1, entry, fetchURLs, buffers;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            weightPath = Array.isArray(this.path) ? this.path[1] : this.path;\n            _a = parseUrl(weightPath), prefix = _a[0], suffix = _a[1];\n            pathPrefix = this.weightPathPrefix || prefix;\n            weightSpecs = [];\n\n            for (_i = 0, weightsManifest_1 = weightsManifest; _i < weightsManifest_1.length; _i++) {\n              entry = weightsManifest_1[_i];\n              weightSpecs.push.apply(weightSpecs, entry.weights);\n            }\n\n            fetchURLs = [];\n            weightsManifest.forEach(function (weightsGroup) {\n              weightsGroup.paths.forEach(function (path) {\n                fetchURLs.push(pathPrefix + path + suffix);\n              });\n            });\n            return [4\n            /*yield*/\n            , weights_loader_1.loadWeightsAsArrayBuffer(fetchURLs, {\n              requestInit: this.requestInit,\n              fetchFunc: this.fetch,\n              onProgress: this.onProgress\n            })];\n\n          case 1:\n            buffers = _b.sent();\n            return [2\n            /*return*/\n            , [weightSpecs, io_utils_1.concatenateArrayBuffers(buffers)]];\n        }\n      });\n    });\n  };\n\n  HTTPRequest.URL_SCHEME_REGEX = /^https?:\\/\\//;\n  return HTTPRequest;\n}();\n\nexports.HTTPRequest = HTTPRequest;\n/**\n * Extract the prefix and suffix of the url, where the prefix is the path before\n * the last file, and suffix is the search params after the last file.\n * ```\n * const url = 'http://tfhub.dev/model/1/tensorflowjs_model.pb?tfjs-format=file'\n * [prefix, suffix] = parseUrl(url)\n * // prefix = 'http://tfhub.dev/model/1/'\n * // suffix = '?tfjs-format=file'\n * ```\n * @param url the model url to be parsed.\n */\n\nfunction parseUrl(url) {\n  var lastSlash = url.lastIndexOf('/');\n  var lastSearchParam = url.lastIndexOf('?');\n  var prefix = url.substring(0, lastSlash);\n  var suffix = lastSearchParam > lastSlash ? url.substring(lastSearchParam) : '';\n  return [prefix + '/', suffix];\n}\n\nexports.parseUrl = parseUrl;\n\nfunction isHTTPScheme(url) {\n  return url.match(HTTPRequest.URL_SCHEME_REGEX) != null;\n}\n\nexports.isHTTPScheme = isHTTPScheme;\n\nexports.httpRouter = function (url, onProgress) {\n  if (typeof fetch === 'undefined') {\n    // `http` uses `fetch` or `node-fetch`, if one wants to use it in\n    // an environment that is not the browser or node they have to setup a\n    // global fetch polyfill.\n    return null;\n  } else {\n    var isHTTP = true;\n\n    if (Array.isArray(url)) {\n      isHTTP = url.every(function (urlItem) {\n        return isHTTPScheme(urlItem);\n      });\n    } else {\n      isHTTP = isHTTPScheme(url);\n    }\n\n    if (isHTTP) {\n      return http(url, {\n        onProgress: onProgress\n      });\n    }\n  }\n\n  return null;\n};\n\nrouter_registry_1.IORouterRegistry.registerSaveRouter(exports.httpRouter);\nrouter_registry_1.IORouterRegistry.registerLoadRouter(exports.httpRouter);\n/**\n * Creates an IOHandler subtype that sends model artifacts to HTTP server.\n *\n * An HTTP request of the `multipart/form-data` mime type will be sent to the\n * `path` URL. The form data includes artifacts that represent the topology\n * and/or weights of the model. In the case of Keras-style `tf.Model`, two\n * blobs (files) exist in form-data:\n *   - A JSON file consisting of `modelTopology` and `weightsManifest`.\n *   - A binary weights file consisting of the concatenated weight values.\n * These files are in the same format as the one generated by\n * [tfjs_converter](https://js.tensorflow.org/tutorials/import-keras.html).\n *\n * The following code snippet exemplifies the client-side code that uses this\n * function:\n *\n * ```js\n * const model = tf.sequential();\n * model.add(\n *     tf.layers.dense({units: 1, inputShape: [100], activation: 'sigmoid'}));\n *\n * const saveResult = await model.save(tf.io.http(\n *     'http://model-server:5000/upload', {method: 'PUT'}));\n * console.log(saveResult);\n * ```\n *\n * If the default `POST` method is to be used, without any custom parameters\n * such as headers, you can simply pass an HTTP or HTTPS URL to `model.save`:\n *\n * ```js\n * const saveResult = await model.save('http://model-server:5000/upload');\n * ```\n *\n * The following GitHub Gist\n * https://gist.github.com/dsmilkov/1b6046fd6132d7408d5257b0976f7864\n * implements a server based on [flask](https://github.com/pallets/flask) that\n * can receive the request. Upon receiving the model artifacts via the requst,\n * this particular server reconsistutes instances of [Keras\n * Models](https://keras.io/models/model/) in memory.\n *\n *\n * @param path A URL path to the model.\n *   Can be an absolute HTTP path (e.g.,\n *   'http://localhost:8000/model-upload)') or a relative path (e.g.,\n *   './model-upload').\n * @param requestInit Request configurations to be used when sending\n *    HTTP request to server using `fetch`. It can contain fields such as\n *    `method`, `credentials`, `headers`, `mode`, etc. See\n *    https://developer.mozilla.org/en-US/docs/Web/API/Request/Request\n *    for more information. `requestInit` must not have a body, because the\n * body will be set by TensorFlow.js. File blobs representing the model\n * topology (filename: 'model.json') and the weights of the model (filename:\n * 'model.weights.bin') will be appended to the body. If `requestInit` has a\n * `body`, an Error will be thrown.\n * @param loadOptions Optional configuration for the loading. It includes the\n *   following fields:\n *   - weightPathPrefix Optional, this specifies the path prefix for weight\n *     files, by default this is calculated from the path param.\n *   - fetchFunc Optional, custom `fetch` function. E.g., in Node.js,\n *     the `fetch` from node-fetch can be used here.\n *   - onProgress Optional, progress callback function, fired periodically\n *     before the load is completed.\n * @returns An instance of `IOHandler`.\n */\n\n/**\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Loading',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\n\nfunction http(path, loadOptions) {\n  return new HTTPRequest(path, loadOptions);\n}\n\nexports.http = http;\n/**\n * Deprecated. Use `tf.io.http`.\n * @param path\n * @param loadOptions\n */\n\nfunction browserHTTPRequest(path, loadOptions) {\n  return http(path, loadOptions);\n}\n\nexports.browserHTTPRequest = browserHTTPRequest;","map":null,"metadata":{},"sourceType":"script"}