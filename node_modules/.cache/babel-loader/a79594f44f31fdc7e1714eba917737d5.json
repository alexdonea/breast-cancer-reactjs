{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tensor_ops_1 = require(\"../ops/tensor_ops\");\n\nvar util_1 = require(\"../util\");\n\nvar types_1 = require(\"./types\");\n/** Number of bytes reserved for the length of the string. (32bit integer). */\n\n\nvar NUM_BYTES_STRING_LENGTH = 4;\n/**\n * Encode a map from names to weight values as an ArrayBuffer, along with an\n * `Array` of `WeightsManifestEntry` as specification of the encoded weights.\n *\n * This function does not perform sharding.\n *\n * This function is the reverse of `decodeWeights`.\n *\n * @param tensors A map (\"dict\") from names to tensors.\n * @param group Group to which the weights belong (optional).\n * @returns A `Promise` of\n *   - A flat `ArrayBuffer` with all the binary values of the `Tensor`s\n *     concatenated.\n *   - An `Array` of `WeightManifestEntry`s, carrying information including\n *     tensor names, `dtype`s and shapes.\n * @throws Error: on unsupported tensor `dtype`.\n */\n\nfunction encodeWeights(tensors, group) {\n  return __awaiter(this, void 0, void 0, function () {\n    var specs, dataPromises, names, _loop_1, i, tensorValues;\n\n    var _this = this;\n\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          specs = [];\n          dataPromises = [];\n          names = Array.isArray(tensors) ? tensors.map(function (tensor) {\n            return tensor.name;\n          }) : Object.keys(tensors);\n\n          _loop_1 = function (i) {\n            var name_1 = names[i];\n            var t = Array.isArray(tensors) ? tensors[i].tensor : tensors[name_1];\n\n            if (t.dtype !== 'float32' && t.dtype !== 'int32' && t.dtype !== 'bool' && t.dtype !== 'string') {\n              throw new Error(\"Unsupported dtype in weight '\" + name_1 + \"': \" + t.dtype);\n            }\n\n            var spec = {\n              name: name_1,\n              shape: t.shape,\n              dtype: t.dtype\n            };\n\n            if (t.dtype === 'string') {\n              var utf8bytes = new Promise(function (resolve) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var vals, totalNumBytes, bytes, offset, i_1, val, bytesOfLength;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        return [4\n                        /*yield*/\n                        , t.bytes()];\n\n                      case 1:\n                        vals = _a.sent();\n                        totalNumBytes = vals.reduce(function (p, c) {\n                          return p + c.length;\n                        }, 0) + NUM_BYTES_STRING_LENGTH * vals.length;\n                        bytes = new Uint8Array(totalNumBytes);\n                        offset = 0;\n\n                        for (i_1 = 0; i_1 < vals.length; i_1++) {\n                          val = vals[i_1];\n                          bytesOfLength = new Uint8Array(new Uint32Array([val.length]).buffer);\n                          bytes.set(bytesOfLength, offset);\n                          offset += NUM_BYTES_STRING_LENGTH;\n                          bytes.set(val, offset);\n                          offset += val.length;\n                        }\n\n                        resolve(bytes);\n                        return [2\n                        /*return*/\n                        ];\n                    }\n                  });\n                });\n              });\n              dataPromises.push(utf8bytes);\n            } else {\n              dataPromises.push(t.data());\n            }\n\n            if (group != null) {\n              spec.group = group;\n            }\n\n            specs.push(spec);\n          };\n\n          for (i = 0; i < names.length; ++i) {\n            _loop_1(i);\n          }\n\n          return [4\n          /*yield*/\n          , Promise.all(dataPromises)];\n\n        case 1:\n          tensorValues = _a.sent();\n          return [2\n          /*return*/\n          , {\n            data: concatenateTypedArrays(tensorValues),\n            specs: specs\n          }];\n      }\n    });\n  });\n}\n\nexports.encodeWeights = encodeWeights;\n/**\n * Decode flat ArrayBuffer as weights.\n *\n * This function does not handle sharding.\n *\n * This function is the reverse of `encodeWeights`.\n *\n * @param buffer A flat ArrayBuffer carrying the binary values of the tensors\n *   concatenated in the order specified in `specs`.\n * @param specs Specifications of the names, dtypes and shapes of the tensors\n *   whose value are encoded by `buffer`.\n * @return A map from tensor name to tensor value, with the names corresponding\n *   to names in `specs`.\n * @throws Error, if any of the tensors has unsupported dtype.\n */\n\nfunction decodeWeights(buffer, specs) {\n  // TODO(adarob, cais): Support quantization.\n  var out = {};\n  var offset = 0;\n\n  var _loop_2 = function (spec) {\n    var name_2 = spec.name;\n    var dtype = spec.dtype;\n    var shape = spec.shape;\n    var size = util_1.sizeFromShape(shape);\n    var values = void 0;\n\n    if ('quantization' in spec) {\n      var quantization_1 = spec.quantization;\n\n      if (quantization_1.dtype !== 'uint8' && quantization_1.dtype !== 'uint16') {\n        throw new Error(\"Weight \" + spec.name + \" has unknown \" + (\"quantization dtype \" + quantization_1.dtype + \". \") + \"Supported quantization dtypes are: 'uint8' and 'uint16'.\");\n      }\n\n      var quantizationSizeFactor = types_1.DTYPE_VALUE_SIZE_MAP[quantization_1.dtype];\n      var byteBuffer = buffer.slice(offset, offset + size * quantizationSizeFactor);\n      var quantizedArray = quantization_1.dtype === 'uint8' ? new Uint8Array(byteBuffer) : new Uint16Array(byteBuffer);\n\n      if (dtype === 'float32') {\n        values = Float32Array.from(quantizedArray, function (v) {\n          return v * quantization_1.scale + quantization_1.min;\n        });\n      } else if (dtype === 'int32') {\n        values = Int32Array.from(quantizedArray, function (v) {\n          return Math.round(v * quantization_1.scale + quantization_1.min);\n        });\n      } else {\n        throw new Error(\"Unsupported dtype in weight '\" + name_2 + \"': \" + dtype);\n      }\n\n      offset += size * quantizationSizeFactor;\n    } else if (dtype === 'string') {\n      var size_1 = util_1.sizeFromShape(spec.shape);\n      values = [];\n\n      for (var i = 0; i < size_1; i++) {\n        var byteLength = new Uint32Array(buffer.slice(offset, offset + NUM_BYTES_STRING_LENGTH))[0];\n        offset += NUM_BYTES_STRING_LENGTH;\n        var bytes = new Uint8Array(buffer.slice(offset, offset + byteLength));\n        values.push(bytes);\n        offset += byteLength;\n      }\n    } else {\n      var dtypeFactor = types_1.DTYPE_VALUE_SIZE_MAP[dtype];\n      var byteBuffer = buffer.slice(offset, offset + size * dtypeFactor);\n\n      if (dtype === 'float32') {\n        values = new Float32Array(byteBuffer);\n      } else if (dtype === 'int32') {\n        values = new Int32Array(byteBuffer);\n      } else if (dtype === 'bool') {\n        values = new Uint8Array(byteBuffer);\n      } else {\n        throw new Error(\"Unsupported dtype in weight '\" + name_2 + \"': \" + dtype);\n      }\n\n      offset += size * dtypeFactor;\n    }\n\n    out[name_2] = tensor_ops_1.tensor(values, shape, dtype);\n  };\n\n  for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {\n    var spec = specs_1[_i];\n\n    _loop_2(spec);\n  }\n\n  return out;\n}\n\nexports.decodeWeights = decodeWeights;\n/**\n * Concatenate TypedArrays into an ArrayBuffer.\n */\n\nfunction concatenateTypedArrays(xs) {\n  // TODO(adarob, cais): Support quantization.\n  if (xs === null) {\n    throw new Error(\"Invalid input value: \" + JSON.stringify(xs));\n  }\n\n  var totalByteLength = 0; // `normalizedXs` is here for this reason: a `TypedArray`'s `buffer'\n  // can have a different byte length from that of the `TypedArray` itself,\n  // for example, when the `TypedArray` is created from an offset in an\n  // `ArrayBuffer`. `normliazedXs` holds `TypedArray`s whose `buffer`s match\n  // the `TypedArray` in byte length. If an element of `xs` does not show\n  // this property, a new `TypedArray` that satisfy this property will be\n  // constructed and pushed into `normalizedXs`.\n\n  var normalizedXs = [];\n  xs.forEach(function (x) {\n    totalByteLength += x.byteLength; // tslint:disable:no-any\n\n    normalizedXs.push(x.byteLength === x.buffer.byteLength ? x : new x.constructor(x));\n\n    if (!(x instanceof Float32Array || x instanceof Int32Array || x instanceof Uint8Array)) {\n      throw new Error(\"Unsupported TypedArray subtype: \" + x.constructor.name);\n    } // tslint:enable:no-any\n\n  });\n  var y = new Uint8Array(totalByteLength);\n  var offset = 0;\n  normalizedXs.forEach(function (x) {\n    y.set(new Uint8Array(x.buffer), offset);\n    offset += x.byteLength;\n  });\n  return y.buffer;\n}\n\nexports.concatenateTypedArrays = concatenateTypedArrays; // Use Buffer on Node.js instead of Blob/atob/btoa\n\nvar useNodeBuffer = typeof Buffer !== 'undefined' && (typeof Blob === 'undefined' || typeof atob === 'undefined' || typeof btoa === 'undefined');\n/**\n * Calculate the byte length of a JavaScript string.\n *\n * Note that a JavaScript string can contain wide characters, therefore the\n * length of the string is not necessarily equal to the byte length.\n *\n * @param str Input string.\n * @returns Byte length.\n */\n\nfunction stringByteLength(str) {\n  if (useNodeBuffer) {\n    return Buffer.byteLength(str);\n  }\n\n  return new Blob([str]).size;\n}\n\nexports.stringByteLength = stringByteLength;\n/**\n * Encode an ArrayBuffer as a base64 encoded string.\n *\n * @param buffer `ArrayBuffer` to be converted.\n * @returns A string that base64-encodes `buffer`.\n */\n\nfunction arrayBufferToBase64String(buffer) {\n  if (useNodeBuffer) {\n    return Buffer.from(buffer).toString('base64');\n  }\n\n  return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)));\n}\n\nexports.arrayBufferToBase64String = arrayBufferToBase64String;\n/**\n * Decode a base64 string as an ArrayBuffer.\n *\n * @param str Base64 string.\n * @returns Decoded `ArrayBuffer`.\n */\n\nfunction base64StringToArrayBuffer(str) {\n  if (useNodeBuffer) {\n    var buf = Buffer.from(str, 'base64');\n    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n  }\n\n  var s = atob(str);\n  var buffer = new Uint8Array(s.length);\n\n  for (var i = 0; i < s.length; ++i) {\n    buffer.set([s.charCodeAt(i)], i);\n  }\n\n  return buffer.buffer;\n}\n\nexports.base64StringToArrayBuffer = base64StringToArrayBuffer;\n/**\n * Concatenate a number of ArrayBuffers into one.\n *\n * @param buffers A number of array buffers to concatenate.\n * @returns Result of concatenating `buffers` in order.\n */\n\nfunction concatenateArrayBuffers(buffers) {\n  var totalByteLength = 0;\n  buffers.forEach(function (buffer) {\n    totalByteLength += buffer.byteLength;\n  });\n  var temp = new Uint8Array(totalByteLength);\n  var offset = 0;\n  buffers.forEach(function (buffer) {\n    temp.set(new Uint8Array(buffer), offset);\n    offset += buffer.byteLength;\n  });\n  return temp.buffer;\n}\n\nexports.concatenateArrayBuffers = concatenateArrayBuffers;\n/**\n * Get the basename of a path.\n *\n * Behaves in a way analogous to Linux's basename command.\n *\n * @param path\n */\n\nfunction basename(path) {\n  var SEPARATOR = '/';\n  path = path.trim();\n\n  while (path.endsWith(SEPARATOR)) {\n    path = path.slice(0, path.length - 1);\n  }\n\n  var items = path.split(SEPARATOR);\n  return items[items.length - 1];\n}\n\nexports.basename = basename;\n/**\n * Populate ModelArtifactsInfo fields for a model with JSON topology.\n * @param modelArtifacts\n * @returns A ModelArtifactsInfo object.\n */\n\nfunction getModelArtifactsInfoForJSON(modelArtifacts) {\n  if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n    throw new Error('Expected JSON model topology, received ArrayBuffer.');\n  }\n\n  return {\n    dateSaved: new Date(),\n    modelTopologyType: 'JSON',\n    modelTopologyBytes: modelArtifacts.modelTopology == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),\n    weightSpecsBytes: modelArtifacts.weightSpecs == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),\n    weightDataBytes: modelArtifacts.weightData == null ? 0 : modelArtifacts.weightData.byteLength\n  };\n}\n\nexports.getModelArtifactsInfoForJSON = getModelArtifactsInfoForJSON;","map":null,"metadata":{},"sourceType":"script"}