{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar environment_1 = require(\"../environment\");\n\nvar util_1 = require(\"../util\");\n\nvar io_utils_1 = require(\"./io_utils\");\n\nvar model_management_1 = require(\"./model_management\");\n\nvar router_registry_1 = require(\"./router_registry\");\n\nvar PATH_SEPARATOR = '/';\nvar PATH_PREFIX = 'tensorflowjs_models';\nvar INFO_SUFFIX = 'info';\nvar MODEL_TOPOLOGY_SUFFIX = 'model_topology';\nvar WEIGHT_SPECS_SUFFIX = 'weight_specs';\nvar WEIGHT_DATA_SUFFIX = 'weight_data';\nvar MODEL_METADATA_SUFFIX = 'model_metadata';\n/**\n * Purge all tensorflow.js-saved model artifacts from local storage.\n *\n * @returns Paths of the models purged.\n */\n\nfunction purgeLocalStorageArtifacts() {\n  if (!environment_1.env().getBool('IS_BROWSER') || typeof window.localStorage === 'undefined') {\n    throw new Error('purgeLocalStorageModels() cannot proceed because local storage is ' + 'unavailable in the current environment.');\n  }\n\n  var LS = window.localStorage;\n  var purgedModelPaths = [];\n\n  for (var i = 0; i < LS.length; ++i) {\n    var key = LS.key(i);\n    var prefix = PATH_PREFIX + PATH_SEPARATOR;\n\n    if (key.startsWith(prefix) && key.length > prefix.length) {\n      LS.removeItem(key);\n      var modelName = getModelPathFromKey(key);\n\n      if (purgedModelPaths.indexOf(modelName) === -1) {\n        purgedModelPaths.push(modelName);\n      }\n    }\n  }\n\n  return purgedModelPaths;\n}\n\nexports.purgeLocalStorageArtifacts = purgeLocalStorageArtifacts;\n\nfunction getModelKeys(path) {\n  return {\n    info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),\n    topology: [PATH_PREFIX, path, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),\n    weightSpecs: [PATH_PREFIX, path, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),\n    weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),\n    modelMetadata: [PATH_PREFIX, path, MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)\n  };\n}\n/**\n * Get model path from a local-storage key.\n *\n * E.g., 'tensorflowjs_models/my/model/1/info' --> 'my/model/1'\n *\n * @param key\n */\n\n\nfunction getModelPathFromKey(key) {\n  var items = key.split(PATH_SEPARATOR);\n\n  if (items.length < 3) {\n    throw new Error(\"Invalid key format: \" + key);\n  }\n\n  return items.slice(1, items.length - 1).join(PATH_SEPARATOR);\n}\n\nfunction maybeStripScheme(key) {\n  return key.startsWith(BrowserLocalStorage.URL_SCHEME) ? key.slice(BrowserLocalStorage.URL_SCHEME.length) : key;\n}\n/**\n * IOHandler subclass: Browser Local Storage.\n *\n * See the doc string to `browserLocalStorage` for more details.\n */\n\n\nvar BrowserLocalStorage =\n/** @class */\nfunction () {\n  function BrowserLocalStorage(modelPath) {\n    if (!environment_1.env().getBool('IS_BROWSER') || typeof window.localStorage === 'undefined') {\n      // TODO(cais): Add more info about what IOHandler subtypes are\n      // available.\n      //   Maybe point to a doc page on the web and/or automatically determine\n      //   the available IOHandlers and print them in the error message.\n      throw new Error('The current environment does not support local storage.');\n    }\n\n    this.LS = window.localStorage;\n\n    if (modelPath == null || !modelPath) {\n      throw new Error('For local storage, modelPath must not be null, undefined or empty.');\n    }\n\n    this.modelPath = modelPath;\n    this.keys = getModelKeys(this.modelPath);\n  }\n  /**\n   * Save model artifacts to browser local storage.\n   *\n   * See the documentation to `browserLocalStorage` for details on the saved\n   * artifacts.\n   *\n   * @param modelArtifacts The model artifacts to be stored.\n   * @returns An instance of SaveResult.\n   */\n\n\n  BrowserLocalStorage.prototype.save = function (modelArtifacts) {\n    return __awaiter(this, void 0, void 0, function () {\n      var topology, weightSpecs, modelArtifactsInfo;\n      return __generator(this, function (_a) {\n        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n          throw new Error('BrowserLocalStorage.save() does not support saving model topology ' + 'in binary formats yet.');\n        } else {\n          topology = JSON.stringify(modelArtifacts.modelTopology);\n          weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);\n          modelArtifactsInfo = io_utils_1.getModelArtifactsInfoForJSON(modelArtifacts);\n\n          try {\n            this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));\n            this.LS.setItem(this.keys.topology, topology);\n            this.LS.setItem(this.keys.weightSpecs, weightSpecs);\n            this.LS.setItem(this.keys.weightData, io_utils_1.arrayBufferToBase64String(modelArtifacts.weightData));\n            this.LS.setItem(this.keys.modelMetadata, JSON.stringify({\n              format: modelArtifacts.format,\n              generatedBy: modelArtifacts.generatedBy,\n              convertedBy: modelArtifacts.convertedBy\n            }));\n            return [2\n            /*return*/\n            , {\n              modelArtifactsInfo: modelArtifactsInfo\n            }];\n          } catch (err) {\n            // If saving failed, clean up all items saved so far.\n            this.LS.removeItem(this.keys.info);\n            this.LS.removeItem(this.keys.topology);\n            this.LS.removeItem(this.keys.weightSpecs);\n            this.LS.removeItem(this.keys.weightData);\n            this.LS.removeItem(this.keys.modelMetadata);\n            throw new Error(\"Failed to save model '\" + this.modelPath + \"' to local storage: \" + \"size quota being exceeded is a possible cause of this failure: \" + (\"modelTopologyBytes=\" + modelArtifactsInfo.modelTopologyBytes + \", \") + (\"weightSpecsBytes=\" + modelArtifactsInfo.weightSpecsBytes + \", \") + (\"weightDataBytes=\" + modelArtifactsInfo.weightDataBytes + \".\"));\n          }\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * Load a model from local storage.\n   *\n   * See the documentation to `browserLocalStorage` for details on the saved\n   * artifacts.\n   *\n   * @returns The loaded model (if loading succeeds).\n   */\n\n\n  BrowserLocalStorage.prototype.load = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var info, out, topology, weightSpecs, metadataString, metadata, weightDataBase64;\n      return __generator(this, function (_a) {\n        info = JSON.parse(this.LS.getItem(this.keys.info));\n\n        if (info == null) {\n          throw new Error(\"In local storage, there is no model with name '\" + this.modelPath + \"'\");\n        }\n\n        if (info.modelTopologyType !== 'JSON') {\n          throw new Error('BrowserLocalStorage does not support loading non-JSON model ' + 'topology yet.');\n        }\n\n        out = {};\n        topology = JSON.parse(this.LS.getItem(this.keys.topology));\n\n        if (topology == null) {\n          throw new Error(\"In local storage, the topology of model '\" + this.modelPath + \"' \" + \"is missing.\");\n        }\n\n        out.modelTopology = topology;\n        weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));\n\n        if (weightSpecs == null) {\n          throw new Error(\"In local storage, the weight specs of model '\" + this.modelPath + \"' \" + \"are missing.\");\n        }\n\n        out.weightSpecs = weightSpecs;\n        metadataString = this.LS.getItem(this.keys.modelMetadata);\n\n        if (metadataString != null) {\n          metadata = JSON.parse(metadataString);\n          out.format = metadata['format'];\n          out.generatedBy = metadata['generatedBy'];\n          out.convertedBy = metadata['convertedBy'];\n        }\n\n        weightDataBase64 = this.LS.getItem(this.keys.weightData);\n\n        if (weightDataBase64 == null) {\n          throw new Error(\"In local storage, the binary weight values of model \" + (\"'\" + this.modelPath + \"' are missing.\"));\n        }\n\n        out.weightData = io_utils_1.base64StringToArrayBuffer(weightDataBase64);\n        return [2\n        /*return*/\n        , out];\n      });\n    });\n  };\n\n  BrowserLocalStorage.URL_SCHEME = 'localstorage://';\n  return BrowserLocalStorage;\n}();\n\nexports.BrowserLocalStorage = BrowserLocalStorage;\n\nexports.localStorageRouter = function (url) {\n  if (!environment_1.env().getBool('IS_BROWSER')) {\n    return null;\n  } else {\n    if (!Array.isArray(url) && url.startsWith(BrowserLocalStorage.URL_SCHEME)) {\n      return browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length));\n    } else {\n      return null;\n    }\n  }\n};\n\nrouter_registry_1.IORouterRegistry.registerSaveRouter(exports.localStorageRouter);\nrouter_registry_1.IORouterRegistry.registerLoadRouter(exports.localStorageRouter);\n/**\n * Factory function for local storage IOHandler.\n *\n * This `IOHandler` supports both `save` and `load`.\n *\n * For each model's saved artifacts, four items are saved to local storage.\n *   - `${PATH_SEPARATOR}/${modelPath}/info`: Contains meta-info about the\n *     model, such as date saved, type of the topology, size in bytes, etc.\n *   - `${PATH_SEPARATOR}/${modelPath}/topology`: Model topology. For Keras-\n *     style models, this is a stringized JSON.\n *   - `${PATH_SEPARATOR}/${modelPath}/weight_specs`: Weight specs of the\n *     model, can be used to decode the saved binary weight values (see\n *     item below).\n *   - `${PATH_SEPARATOR}/${modelPath}/weight_data`: Concatenated binary\n *     weight values, stored as a base64-encoded string.\n *\n * Saving may throw an `Error` if the total size of the artifacts exceed the\n * browser-specific quota.\n *\n * @param modelPath A unique identifier for the model to be saved. Must be a\n *   non-empty string.\n * @returns An instance of `IOHandler`, which can be used with, e.g.,\n *   `tf.Model.save`.\n */\n\nfunction browserLocalStorage(modelPath) {\n  return new BrowserLocalStorage(modelPath);\n}\n\nexports.browserLocalStorage = browserLocalStorage;\n\nvar BrowserLocalStorageManager =\n/** @class */\nfunction () {\n  function BrowserLocalStorageManager() {\n    util_1.assert(environment_1.env().getBool('IS_BROWSER'), function () {\n      return 'Current environment is not a web browser';\n    });\n    util_1.assert(typeof window.localStorage !== 'undefined', function () {\n      return 'Current browser does not appear to support localStorage';\n    });\n    this.LS = window.localStorage;\n  }\n\n  BrowserLocalStorageManager.prototype.listModels = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var out, prefix, suffix, i, key, modelPath;\n      return __generator(this, function (_a) {\n        out = {};\n        prefix = PATH_PREFIX + PATH_SEPARATOR;\n        suffix = PATH_SEPARATOR + INFO_SUFFIX;\n\n        for (i = 0; i < this.LS.length; ++i) {\n          key = this.LS.key(i);\n\n          if (key.startsWith(prefix) && key.endsWith(suffix)) {\n            modelPath = getModelPathFromKey(key);\n            out[modelPath] = JSON.parse(this.LS.getItem(key));\n          }\n        }\n\n        return [2\n        /*return*/\n        , out];\n      });\n    });\n  };\n\n  BrowserLocalStorageManager.prototype.removeModel = function (path) {\n    return __awaiter(this, void 0, void 0, function () {\n      var keys, info;\n      return __generator(this, function (_a) {\n        path = maybeStripScheme(path);\n        keys = getModelKeys(path);\n\n        if (this.LS.getItem(keys.info) == null) {\n          throw new Error(\"Cannot find model at path '\" + path + \"'\");\n        }\n\n        info = JSON.parse(this.LS.getItem(keys.info));\n        this.LS.removeItem(keys.info);\n        this.LS.removeItem(keys.topology);\n        this.LS.removeItem(keys.weightSpecs);\n        this.LS.removeItem(keys.weightData);\n        return [2\n        /*return*/\n        , info];\n      });\n    });\n  };\n\n  return BrowserLocalStorageManager;\n}();\n\nexports.BrowserLocalStorageManager = BrowserLocalStorageManager;\n\nif (environment_1.env().getBool('IS_BROWSER')) {\n  // Wrap the construction and registration, to guard against browsers that\n  // don't support Local Storage.\n  try {\n    model_management_1.ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME, new BrowserLocalStorageManager());\n  } catch (err) {}\n}","map":null,"metadata":{},"sourceType":"script"}